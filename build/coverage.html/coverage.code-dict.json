{"/home/travis/build/npmtest/node-npmtest-nodal/test.js":"/* istanbul instrument in package npmtest_nodal */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nodal/lib.npmtest_nodal.js":"/* istanbul instrument in package npmtest_nodal */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_nodal = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_nodal = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-nodal/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-nodal && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_nodal */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_nodal\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_nodal.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_nodal.rollup.js'] =\n            local.assetsDict['/assets.npmtest_nodal.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_nodal.__dirname + '/lib.npmtest_nodal.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/module.js":"'use strict';\n\n// This will load dotenv / etc.\nconst fxn  = require('fxn');\n\nlet types = require('pg').types;\ntypes.setTypeParser(20, function(val) {\n  return val === null ? null : parseInt(val);\n}); // 64-bit integer\ntypes.setTypeParser(1700, function(val) {\n  return val === null ? null : parseFloat(val);\n}); // type NUMERIC\n\nlet Nodal = {\n  API: null,\n  APIResource: null,\n  Application: null,\n  Controller: null,\n  CLI: null,\n  Daemon: null,\n  Database: null,\n  GraphQuery: null,\n  ItemArray: null,\n  Migration: null,\n  Mime: null,\n  Model: null,\n  ModelArray: null,\n  ModelFactory: null,\n  RelationshipGraph: null,\n  Router: null,\n  Scheduler: null,\n  SchemaGenerator: null,\n  my: {\n    Config: null,\n    Schema: null,\n    bootstrapper: null\n  },\n  mocha: {\n    Test: null,\n    TestRunner: null\n  }\n};\n\n/* Lazy Loading */\n\nlet LazyNodal = {\n  my: {},\n  mocha: {},\n  require: function(filename) {\n    return require(process.cwd() + '/' + filename);\n  },\n  include: {\n    mime: require('mime-types'),\n    inflect: require('i')()\n  },\n  env: require('./env.js')()\n};\n\nObject.defineProperties(LazyNodal, {\n  API: {\n    get: function() {\n      return Nodal.API || (Nodal.API = require('./required/api.js'));\n    },\n    enumerable: true\n  },\n  APIResource: {\n    get: function() {\n      return Nodal.APIResource || (Nodal.APIResource = require('api-res'));\n    }\n  },\n  Application: {\n    get: function() {\n      return Nodal.Application || (Nodal.Application = require('./required/application.js'));\n    },\n    enumerable: true\n  },\n  Controller: {\n    get: function() {\n      return Nodal.Controller || (Nodal.Controller = require('./required/controller.js'));\n    },\n    enumerable: true\n  },\n  CLI: {\n    get: function() {\n      return Nodal.CLI || (Nodal.CLI = require('../cli/cli.js'));\n    },\n    enumerable: true\n  },\n  Daemon: {\n    get: function() {\n      return Nodal.Daemon || (Nodal.Daemon = require('./required/daemon.js'));\n    },\n    enumerable: true\n  },\n  Database: {\n    get: function() {\n      return Nodal.Database || (Nodal.Database = require('./required/db/database.js'));\n    },\n    enumerable: true\n  },\n  GraphQuery: {\n    get: function() {\n      return Nodal.GraphQuery || (Nodal.GraphQuery = require('./required/graph_query.js'));\n    },\n    enumerable: true\n  },\n  ItemArray: {\n    get: function() {\n      return Nodal.ItemArray || (Nodal.ItemArray = require('./required/item_array.js'));\n    },\n    enumerable: true\n  },\n  Migration: {\n    get: function() {\n      return Nodal.Migration || (Nodal.Migration = require('./required/db/migration.js'));\n    },\n    enumerable: true\n  },\n  Mime: {\n    get: function() {\n      return Nodal.Mime || (Nodal.Mime = require('./required/mime.js'));\n    },\n    enumerable: true\n  },\n  Model: {\n    get: function() {\n      return Nodal.Model || (Nodal.Model = require('./required/model.js'));\n    },\n    enumerable: true\n  },\n  ModelArray: {\n    get: function() {\n      return Nodal.ModelArray || (Nodal.ModelArray = require('./required/model_array.js'));\n    },\n    enumerable: true\n  },\n  ModelFactory: {\n    get: function() {\n      return Nodal.ModelFactory || (Nodal.ModelFactory = require('./required/model_factory.js'));\n    },\n    enumerable: true\n  },\n  RelationshipGraph: {\n    get: function() {\n      return Nodal.RelationshipGraph || (Nodal.RelationshipGraph = require('./required/relationship_graph.js'));\n    },\n    enumerable: true\n  },\n  Router: {\n    get: function() {\n      return Nodal.Router || (Nodal.Router = require('./required/router.js'));\n    },\n    enumerable: true\n  },\n  Scheduler: {\n    get: function() {\n      return Nodal.Scheduler || (Nodal.Scheduler = require('./required/scheduler.js'));\n    },\n    enumerable: true\n  },\n  SchemaGenerator: {\n    get: function() {\n      return Nodal.SchemaGenerator || (Nodal.SchemaGenerator = require('./required/db/schema_generator.js'));\n    },\n    enumerable: true\n  }\n});\n\nObject.defineProperties(LazyNodal.my, {\n  Config: {\n    get: function() {\n      return Nodal.my.Config || (Nodal.my.Config = require('./my/config.js'));\n    },\n    enumerable: true\n  },\n  Schema: {\n    get: function() {\n      return Nodal.my.Schema || (Nodal.my.Schema = require('./my/schema.js'));\n    },\n    enumerable: true\n  },\n  bootstrapper: {\n    get: function() {\n      return Nodal.my.bootstrapper || (Nodal.my.bootstrapper = require('./my/bootstrapper.js'));\n    },\n    enumerable: true\n  }\n});\n\nObject.defineProperties(LazyNodal.mocha, {\n  Test: {\n    get: function() {\n      return Nodal.mocha.Test || (Nodal.mocha.Test = require('./mocha/test.js'));\n    },\n    enumerable: true\n  },\n  TestRunner: {\n    get: function() {\n      return Nodal.mocha.TestRunner || (Nodal.mocha.TestRunner = require('./mocha/test_runner.js'));\n    },\n    enumerable: true\n  }\n});\n\nmodule.exports = LazyNodal;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/env.js":"module.exports = () => {\n\n  return {\n    name: process.env.NODE_ENV || 'development',\n    rootDirectory: process.env.ROOT_DIRECTORY || process.cwd()\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/required/api.js":"'use strict';\n\nconst Model = require('./model.js');\nconst ItemArray = require('./item_array.js');\nconst ModelArray = require('./model_array.js');\n\nclass APIConstructor {\n\n  format(obj, arrInterface, useResource) {\n\n    if (obj instanceof Error) {\n      return this.error(obj.message, obj.details);\n    }\n\n    if (obj instanceof Model) {\n      let modelArray = new ModelArray(obj.constructor);\n      modelArray.setMeta({total: 1, offset: 0});\n      modelArray.push(obj);\n      obj = modelArray;\n    }\n\n    if (!(obj instanceof ItemArray)) {\n      return this.spoof(obj);\n    }\n\n    return this.response(obj, arrInterface);\n\n  }\n\n  meta(total, count, offset, error, summary, resource) {\n\n    if (error) {\n      total = 0;\n      count = 0;\n      offset = 0;\n      resource = null;\n    }\n\n    let meta = {\n      total: total,\n      count: count,\n      offset: offset,\n      error: error\n    };\n\n    summary && (meta.summary = summary);\n    resource && (meta.resource = resource);\n\n    return meta;\n\n  }\n\n  error(message, details) {\n\n    return {\n      meta: this.meta(0, 0, 0, {message: message, details: details}),\n      data: []\n    };\n\n  }\n\n  spoof(obj, useResource) {\n\n    if (!(obj instanceof Array)) {\n      obj = [obj];\n    }\n\n    return {\n      meta: this.meta(\n        obj.length,\n        obj.length,\n        0,\n        null,\n        null,\n        useResource && this.resourceFromArray(obj)\n      ),\n      data: obj\n    }\n\n  }\n\n  response(itemArray, arrInterface, useResource) {\n\n    return {\n      meta: this.meta(\n        itemArray._meta.total,\n        itemArray.length,\n        itemArray._meta.offset,\n        null,\n        null,\n        useResource && this.resourceFromModelArray(itemArray, arrInterface)\n      ),\n      data: itemArray.toObject(arrInterface)\n    }\n\n  }\n\n  resourceFromArray(arr) {\n\n    function getType(v) {\n      v = (v instanceof Array) ? v[0] : v;\n      return {\n        'boolean': 'boolean',\n        'string': 'string',\n        'number': 'float'\n      }[(typeof v)] || ((v instanceof Date) ? 'datetime' : 'string');\n    };\n\n    let fields = [];\n\n    if (arr.length && arr[0] && typeof arr[0] === 'object') {\n      let datum = arr[0];\n      fields = Object.keys(datum).map(function(v, i) {\n\n        return {\n          name: v,\n          type: getType(datum[v]),\n          array: (v instanceof Array)\n        }\n\n      });\n    }\n\n    return {\n      name: 'object',\n      fields: fields\n    }\n\n  }\n\n  resourceFromModelArray(modelArray, arrInterface) {\n\n    return modelArray._modelConstructor.toResource(arrInterface);\n\n  }\n\n}\n\nmodule.exports = new APIConstructor();\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/required/model.js":"'use strict';\n\nconst DataTypes = require('./db/data_types.js');\nconst Database = require('./db/database.js');\nconst Composer = require('./composer.js');\n\nconst ModelArray = require('./model_array.js');\n\nconst utilities = require('./utilities.js');\nconst async = require('async');\nconst inflect = require('i')();\nconst deepEqual = require('deep-equal');\n\nconst RelationshipGraph = require('./relationship_graph.js');\nconst Relationships = new RelationshipGraph();\n\n/**\n* Basic Model implementation. Optionally interfaces with database.\n* @class\n*/\nclass Model {\n\n  /**\n  * @param {Object} modelData Data to load into the object\n  * @param {optional boolean} fromStorage Is this model being loaded from storage? Defaults to false.\n  * @param {option boolean} fromSeed Is this model being seeded?\n  */\n  constructor(modelData, fromStorage, fromSeed) {\n\n    modelData = modelData || {};\n\n    this.__initialize__();\n    this.__load__(modelData, fromStorage, fromSeed);\n\n  }\n\n  /**\n  * Finds a model with a provided id, otherwise returns a notFound error.\n  * @param {number} id The id of the model you're looking for\n  * @param {function({Error} err, {Nodal.Model} model)} callback The callback to execute upon completion\n  */\n  static find(id, callback) {\n\n    let db = this.prototype.db;\n\n    // legacy support\n    if (arguments.length === 3) {\n      db = arguments[0];\n      id = arguments[1];\n      callback = arguments[2];\n    }\n\n    return new Composer(this)\n      .where({id: id})\n      .end((err, models) => {\n\n        if (!err && !models.length) {\n          let err = new Error(`Could not find ${this.name} with id \"${id}\".`);\n          err.notFound = true;\n          return callback(err);\n        }\n\n        callback(err, models[0]);\n\n      });\n\n  }\n\n  /**\n  * Finds a model with a provided field, value pair. Returns the first found.\n  * @param {string} field Name of the field\n  * @param {any} value Value of the named field to compare against\n  * @param {function({Error} err, {Nodal.Model} model)} callback The callback to execute upon completion\n  */\n  static findBy(field, value, callback) {\n\n    let db = this.prototype.db;\n    let query = {};\n    query[field] = value;\n\n    return new Composer(this)\n      .where(query)\n      .end((err, models) => {\n\n        if (!err && !models.length) {\n          let err = new Error(`Could not find ${this.name} with ${field} \"${value}\".`);\n          err.notFound = true;\n          return callback(err);\n        }\n\n        callback(err, models[0]);\n\n      });\n\n  }\n\n  /**\n  * Creates a new model instance using the provided data.\n  * @param {object} data The data to load into the object.\n  * @param {function({Error} err, {Nodal.Model} model)} callback The callback to execute upon completion\n  */\n  static create(data, callback) {\n\n    let model = new this(data);\n    model.save(callback);\n\n  }\n\n  /**\n  * Finds a model with a provided field, value pair. Returns the first found.\n  * @param {string} field Name of the field\n  * @param {object} data Key-value pairs of Model creation data. Will use appropriate value to query for based on \"field\" parametere.\n  * @param {function({Error} err, {Nodal.Model} model)} callback The callback to execute upon completion\n  */\n  static findOrCreateBy(field, data, callback) {\n\n    this.findBy(field, data[field], (err, model) => {\n\n      if (err) {\n        if (err.notFound) {\n          return this.create(data, callback);\n        } else {\n          return callback(err);\n        }\n      } else {\n        return callback(null, model);\n      }\n\n    });\n\n  }\n\n  /**\n  * Finds and updates a model with a specified id. Return a notFound error if model does not exist.\n  * @param {number} id The id of the model you're looking for\n  * @param {object} data The data to load into the object.\n  * @param {function({Error} err, {Nodal.Model} model)} callback The callback to execute upon completion\n  */\n  static update(id, data, callback) {\n\n    this.find(id, (err, model) => {\n\n      if (err) {\n        return callback(err);\n      }\n\n      model.read(data);\n      model.save(callback);\n\n    });\n\n  }\n\n  /**\n  * Finds and destroys a model with a specified id. Return a notFound error if model does not exist.\n  * @param {number} id The id of the model you're looking for\n  * @param {function({Error} err, {Nodal.Model} model)} callback The callback to execute upon completion\n  */\n  static destroy(id, callback) {\n\n    this.find(id, (err, model) => {\n\n      if (err) {\n        return callback(err);\n      }\n\n      model.destroy(callback);\n\n    });\n\n  }\n\n  /**\n  * Creates a new Composer (ORM) instance to begin a new query.\n  * @param {optional Nodal.Database} db Deprecated - provide a database to query from. Set the model's db in its constructor file, instead.\n  * @return {Nodal.Composer}\n  */\n  static query(db) {\n\n    db = db || this.prototype.db;\n    return new Composer(this);\n\n  }\n\n  /**\n  * Creates a transaction object to be passed to database methods\n  * @param {Function} callback Callback to execute upon completion\n  */\n  static transaction(callback) {\n\n    return this.prototype.db.adapter.createTransaction(callback);\n\n  }\n\n  /**\n  * Get the model's table name\n  * @return {string}\n  */\n  static table() {\n    return this.prototype.schema.table;\n  }\n\n  /**\n  * Get the model's column data\n  * @return {Array}\n  */\n  static columns() {\n    return this.prototype.schema.columns;\n  };\n\n  /**\n  * Get the model's column names (fields)\n  * @return {Array}\n  */\n  static columnNames() {\n    return this.columns().map(v => v.name);\n  }\n\n  /**\n  * Get the model's column lookup data\n  * @return {Object}\n  */\n  static columnLookup() {\n    return this.columns().reduce((p, c) => {\n      p[c.name] = c;\n      return p;\n    }, {});\n  }\n\n  /**\n  * Check if the model has a column name in its schema\n  * @param {string} columnName\n  */\n  static hasColumn(columnName) {\n    return !!this.column(columnName);\n  }\n\n  /**\n  * Return the column schema data for a given name\n  * @param {string} columnName\n  */\n  static column(columnName) {\n    return this.prototype._columnLookup[columnName];\n  }\n\n  /**\n  * Get resource data for a model, for API responses and debug information\n  * @param {Array} arrInterface Array of strings representing output columns, or singularly-keyed objects representing relationships and their interface.\n  * @return {Object} Resource object for the model\n  * @deprecated\n  */\n  static toResource(arrInterface) {\n\n    if (!arrInterface || !arrInterface.length) {\n      arrInterface = this.columnNames().concat(\n        Object.keys(this.prototype._joins)\n          .map(r => {\n            let obj = {};\n            obj[r] = this.joinInformation(r).Model.columnNames();\n            return obj;\n          })\n      );\n    }\n\n\n    let columnLookup = this.columnLookup();\n\n    let resourceColumns = arrInterface.map(r => {\n\n      if (typeof r === 'string') {\n\n        let field = columnLookup[r];\n\n        if (!field) {\n          return null;\n        }\n\n        let fieldData = {\n          name: r,\n          type: field ? field.type : 'string'\n        };\n\n        field.array && (fieldData.array = true);\n\n        return fieldData;\n\n      } else if (typeof r === 'object' && r !== null) {\n\n        return null; // FIXME: Deprecated for relationships.\n\n        let key = Object.keys(r)[0];\n        let relationship = this.joinInformation(key);\n\n        if (!relationship) {\n          return null;\n        }\n\n        return relationship.Model.toResource(r[key]);\n\n      }\n\n    }).filter(r => r);\n\n    return {\n      name: this.name,\n      type: 'resource',\n      fields: resourceColumns\n    };\n\n  }\n\n  /**\n  * Set the database to be used for this model\n  * @param {Nodal.Database} db\n  */\n  static setDatabase(db) {\n\n    this.prototype.db = db;\n\n  }\n\n  /**\n  * Set the schema to be used for this model\n  * @param {Object} schema\n  */\n  static setSchema(schema) {\n\n    if (!schema) {\n      throw new Error([\n        `Could not set Schema for ${this.name}.`,\n        `Please make sure to run any outstanding migrations.`\n      ].join('\\n'));\n    }\n\n    this.prototype.schema = schema;\n\n    this.prototype._table = this.table();\n    this.prototype._columns = this.columns();\n    this.prototype._columnNames = this.columnNames();\n    this.prototype._columnLookup = this.columnLookup();\n\n    this.prototype._data = this.columnNames()\n      .reduce((p, c) => {\n        p[c] = null;\n        return p;\n      }, {});\n\n    this.prototype._changed = this.columnNames()\n      .reduce((p, c) => {\n        p[c] = false;\n        return p;\n      }, {});\n\n  }\n\n  /**\n  * FIXME\n  */\n  static relationships() {\n\n    return Relationships.of(this);\n\n  }\n\n  /**\n  * FIXME\n  */\n  static relationship(name) {\n\n    this._relationshipCache = this._relationshipCache || {};\n    this._relationshipCache[name] = (this._relationshipCache[name] || this.relationships().findExplicit(name));\n    return this._relationshipCache[name];\n\n  }\n\n  /**\n  * Sets a joins relationship for the Model. Sets joinedBy relationship for parent.\n  * @param {class Nodal.Model} Model The Model class which your current model belongs to\n  * @param {Object} [options={}]\n  *   \"name\": The string name of the parent in the relationship (default to camelCase of Model name)\n  *   \"via\": Which field in current model represents this relationship, defaults to `${name}_id`\n  *   \"as\": What to display the name of the child as when joined to the parent (default to camelCase of child name)\n  *   \"multiple\": Whether the child exists in multiples for the parent (defaults to false)\n  */\n  static joinsTo(Model, options) {\n\n    return this.relationships().joinsTo(Model, options);\n\n  }\n\n  /**\n  * Create a validator. These run synchronously and check every time a field is set / cleared.\n  * @param {string} field The field you'd like to validate\n  * @param {string} message The error message shown if a validation fails.\n  * @param {function({any} value)} fnAction the validation to run - first parameter is the value you're testing.\n  */\n  static validates(field, message, fnAction) {\n\n    if (!this.prototype.hasOwnProperty('_validations')) {\n      this.prototype._validations = {};\n      this.prototype._validationsList = [];\n    };\n\n    if (!this.prototype._validations[field]) {\n      this.prototype._validationsList.push(field);\n    }\n\n    this.prototype._validations[field] = this.prototype._validations[field] || [];\n    this.prototype._validations[field].push({message: message, action: fnAction});\n\n  }\n\n  /**\n  * Creates a verifier. These run asynchronously, support multiple fields, and check every time you try to save a Model.\n  * @param {string} field The field applied to the verification.\n  * @param {string} message The error message shown if a verification fails.\n  * @param {function} fnAction The asynchronous verification method. The last argument passed is always a callback, and field names are determined by the argument names.\n  */\n  static verifies(field, message, fnAction) {\n\n    // Legacy support\n    if (arguments.length === 2) {\n      fnAction = message;\n      message = field;\n      field = null;\n    }\n\n    if (!this.prototype.hasOwnProperty('_verificationsList')) {\n      this.prototype._verificationsList = [];\n    };\n\n    this.prototype._verificationsList.push({\n      field: field,\n      message: message,\n      action: fnAction,\n      fields: utilities.getFunctionParameters(fnAction).slice(0, -1)\n    });\n\n  }\n\n  /**\n  * Create a calculated field (in JavaScript). Must be synchronous.\n  * @param {string} calcField The name of the calculated field\n  * @param {function} fnCalculate The synchronous method to perform a calculation for.\n  *   Pass the names of the (non-computed) fields you'd like to use as parameters.\n  */\n  static calculates(calcField, fnCompute) {\n\n    if (!this.prototype.hasOwnProperty('_calculations')) {\n      this.prototype._calculations = {};\n      this.prototype._calculationsList = [];\n    }\n\n    if (this.prototype._calculations[calcField]) {\n      throw new Error(`Calculated field \"${calcField}\" for \"${this.name}\" already exists!`);\n    }\n\n    let columnLookup = this.columnLookup();\n\n    if (columnLookup[calcField]) {\n      throw new Error(`Cannot create calculated field \"${calcField}\" for \"${this.name}\", field already exists.`);\n    }\n\n    let fields = utilities.getFunctionParameters(fnCompute);\n\n    fields.forEach(f => {\n      if (!columnLookup[f]) {\n        throw new Error(`Calculation function error: \"${calcField} for \"${this.name}\" using field \"${f}\", \"${f}\" does not exist.`)\n      }\n    });\n\n    this.prototype._calculations[calcField] = {\n      calculate: fnCompute,\n      fields: fields\n    };\n\n    this.prototype._calculationsList.push(calcField);\n\n  }\n\n  /**\n  * Hides fields from being output in .toObject() (i.e. API responses), even if asked for\n  * @param {String} field\n  */\n  static hides(field) {\n\n    if (!this.prototype.hasOwnProperty('_hides')) {\n      this.prototype._hides = {};\n    }\n\n    this.prototype._hides[field] = true;\n    return true;\n\n  }\n\n  /**\n  * Tells us if a field is hidden (i.e. from API queries)\n  * @param {String} field\n  */\n  static isHidden(field) {\n\n    return this.prototype._hides[field] || false;\n\n  }\n\n  /**\n  * Prepare model for use\n  * @private\n  */\n  __initialize__() {\n\n    this._relationshipCache = {};\n\n    this._joinsCache = {};\n    this._joinsList = [];\n\n    this._data = Object.create(this._data); // Inherit from prototype\n    this._changed = Object.create(this._changed); // Inherit from prototype\n    this._errors = {};\n\n    return true;\n\n  }\n\n  /**\n  * Loads data into the model\n  * @private\n  * @param {Object} data Data to load into the model\n  * @param {optional boolean} fromStorage Specify if the model was loaded from storage. Defaults to false.\n  * @param {optional boolean} fromSeed Specify if the model was generated from a seed. Defaults to false.\n  */\n  __load__(data, fromStorage, fromSeed) {\n\n    data = data || {};\n\n    this._inStorage = !!fromStorage;\n    this._isSeeding = !!fromSeed;\n\n    if (!fromStorage) {\n      data.created_at = new Date();\n      data.updated_at = new Date();\n    }\n\n    let keys = Object.keys(data);\n\n    keys.forEach(key => {\n      this.__safeSet__(key, data[key]);\n      this._changed[key] = !fromStorage\n    });\n\n    this.__validate__();\n\n    return this;\n\n  }\n\n  /**\n  * Validates provided fieldList (or all fields if not provided)\n  * @private\n  * @param {optional Array} fieldList fields to validate\n  */\n  __validate__(field) {\n\n    let data = this._data;\n\n    if (!field) {\n\n      let valid = true;\n      this._validationsList.forEach(field => valid = (this.__validate__(field) && valid));\n      return valid;\n\n    } else if (!this._validations[field]) {\n\n      return true;\n\n    }\n\n    this.clearError(field);\n    let value = this._data[field];\n\n    return this._validations[field].filter(validation => {\n      let valid = validation.action.call(null, value);\n      !valid && this.setError(field, validation.message);\n      return valid;\n    }).length === 0;\n\n  }\n\n  /**\n  * Sets specified field data for the model, assuming data is safe and does not log changes\n  * @param {string} field Field to set\n  * @param {any} value Value for the field\n  */\n  __safeSet__(field, value) {\n\n    if (this.relationship(field)) {\n\n      return this.setJoined(field, value);\n\n    }\n\n    if (!this.hasField(field)) {\n\n      return;\n\n    }\n\n    this._data[field] = this.convert(field, value);\n\n  }\n\n  /**\n  * Indicates whethere or not the model is currently represented in hard storage (db).\n  * @return {boolean}\n  */\n  inStorage() {\n    return this._inStorage;\n  }\n\n  /**\n  * Indicates whethere or not the model is being generated from a seed.\n  * @return {boolean}\n  */\n  isSeeding() {\n    return this._isSeeding;\n  }\n\n  /**\n  * Tells us whether a model field has changed since we created it or loaded it from storage.\n  * @param {string} field The model field\n  * @return {boolean}\n  */\n  hasChanged(field) {\n    return field === undefined ? this.changedFields().length > 0 : !!this._changed[field];\n  }\n\n  /**\n  * Provides an array of all changed fields since model was created / loaded from storage\n  * @return {Array}\n  */\n  changedFields() {\n    let changed = this._changed;\n    return Object.keys(changed).filter(v => changed[v]);\n  }\n\n  /**\n  * Creates an error object for the model if any validations have failed, returns null otherwise\n  * @return {Error}\n  */\n  errorObject() {\n\n    let error = null;\n\n    if (this.hasErrors()) {\n\n      let errorObject = this.getErrors();\n      let message = errorObject._query || 'Validation error';\n\n      error = new Error(message);\n      error.details = errorObject;\n\n    }\n\n    return error;\n\n  }\n\n  /**\n  * Tells us whether or not the model has errors (failed validations)\n  * @return {boolean}\n  */\n  hasErrors() {\n\n    return Object.keys(this._errors).length > 0;\n\n  }\n\n  /**\n  * Gives us an error object with each errored field as a key, and each value\n  * being an array of failure messages from the validators\n  * @return {Object}\n  */\n  getErrors() {\n    let obj = {};\n    let errors = this._errors;\n    Object.keys(errors).forEach(function(key) {\n      obj[key] = errors[key];\n    });\n    return obj;\n  }\n\n  /**\n  * Reads new data into the model.\n  * @param {Object} data Data to inject into the model\n  * @return {this}\n  */\n  read(data) {\n\n    this.fieldList()\n      .concat(this._joinsList)\n      .filter((key) => data.hasOwnProperty(key))\n      .forEach((key) => this.set(key, data[key]));\n\n    return this;\n\n  }\n\n  /**\n  * Converts a value to its intended format based on its field. Returns null if field not found.\n  * @param {string} field The field to use for conversion data\n  * @param {any} value The value to convert\n  */\n  convert(field, value) {\n\n    if (!this.hasField(field) || value === null || value === undefined) {\n      return null;\n    }\n\n    let dataType = this.getDataTypeOf(field);\n\n    if (this.isFieldArray(field)) {\n      return (value instanceof Array ? value : [value]).map(v => dataType.convert(v));\n    }\n\n    return dataType.convert(value);\n\n  }\n\n  /**\n  * Grabs the path of the given relationship from the RelationshipGraph\n  * @param {string} name the name of the relationship\n  */\n  relationship(name) {\n    return this.constructor.relationship(name);\n  }\n\n  /**\n  * Sets specified field data for the model. Logs and validates the change.\n  * @param {string} field Field to set\n  * @param {any} value Value for the field\n  */\n  set(field, value) {\n\n    if (!this.hasField(field)) {\n\n      throw new Error('Field ' + field + ' does not belong to model ' + this.constructor.name);\n\n    }\n\n    let curValue = this._data[field];\n    let changed = false;\n    value = this.convert(field, value);\n\n    if (value !== curValue) {\n\n      changed = true;\n\n      if (\n        value instanceof Array &&\n        curValue instanceof Array &&\n        value.length === curValue.length\n      ) {\n\n        changed = false;\n        // If we have two equal length arrays, we must compare every value\n\n        for (let i = 0; i < value.length; i++) {\n          if (value[i] !== curValue[i]) {\n            changed = true;\n            break;\n          }\n        }\n      }\n\n      // If we have an object value (json), do a deterministic diff using\n      // node-deep-equals\n      // NOTE: Lets do an extra deep object test\n      if ( utilities.isObject(value) ) {\n        changed = !deepEqual( curValue, value, { strict: true});\n      }\n\n    }\n\n    this._data[field] = value;\n    this._changed[field] = changed;\n    changed && this.__validate__(field);\n\n    return value;\n\n  }\n\n  /**\n  * Set a joined object (Model or ModelArray)\n  * @param {string} field The field (name of the join relationship)\n  * @param {Model|ModelArray} value The joined model or array of models\n  */\n  setJoined(field, value) {\n\n    let relationship = this.relationship(field);\n\n    if (!relationship.multiple()) {\n\n      if (!(value instanceof relationship.getModel())) {\n\n        throw new Error(`${value} is not an instance of ${relationship.getModel().name}`);\n\n      }\n\n    } else {\n\n      if (!(value instanceof ModelArray) && ModelArray.Model !== relationship.getModel()) {\n\n        throw new Error(`${value} is not an instanceof ModelArray[${relationship.getModel().name}]`);\n\n      }\n\n    }\n\n    if (!this._joinsCache[field]) {\n      this._joinsList.push(field);\n    }\n\n    this._joinsCache[field] = value;\n\n    return value;\n\n  }\n\n  /**\n  * Calculate field from calculations (assumes it exists)\n  *  @param {string} field Name of the calculated field\n  */\n  calculate(field) {\n    let calc = this._calculations[field];\n    return calc.calculate.apply(\n      this,\n      calc.fields.map(f => this.get(f))\n    );\n  }\n\n  /**\n  * Retrieve field data for the model.\n  * @param {string} field Field for which you'd like to retrieve data.\n  */\n  get(field, defaultValue) {\n\n    if (this._calculations[field]) {\n      return this.calculate(field);\n    }\n\n    return this._data.hasOwnProperty(field) ? this._data[field] : defaultValue;\n\n  }\n\n  /**\n  * Retrieves joined Model or ModelArray\n  * @param {String} joinName the name of the join (list of connectors separated by __)\n  */\n  joined(joinName) {\n\n    return this._joinsCache[joinName];\n\n  }\n\n  /**\n  * Retrieve associated models joined this model from the database.\n  * @param {function({Error} err, {Nodal.Model|Nodal.ModelArray} model_1, ... {Nodal.Model|Nodal.ModelArray} model_n)}\n  *   Pass in a function with named parameters corresponding the relationships you'd like to retrieve.\n  *   The first parameter is always an error callback.\n  */\n  include(callback) {\n\n    let db = this.db;\n\n    // legacy support\n    if (arguments.length === 2) {\n      db = arguments[0];\n      callback = arguments[1];\n    }\n\n    let joinNames = utilities.getFunctionParameters(callback);\n    joinNames = joinNames.slice(1);\n\n    if (!joinNames.length) {\n      throw new Error('No valid relationships (1st parameter is error)');\n    }\n\n    let invalidJoinNames = joinNames.filter(r => !this.relationship(r));\n\n    if (invalidJoinNames.length) {\n      throw new Error(`Joins \"${invalidJoinNames.join('\", \"')}\" for model \"${this.constructor.name}\" do not exist.`);\n    }\n\n    let query = this.constructor.query().where({id: this.get('id')});\n\n    joinNames.forEach(joinName => query = query.join(joinName));\n\n    query.end((err, models) => {\n\n      if (err) {\n        return callback(err);\n      }\n\n      if (!models || !models.length) {\n        return callback(new Error('Could not fetch parent'));\n      }\n\n      let model = models[0];\n      let joins = joinNames.map(joinName => {\n        let join = model.joined(joinName);\n        join && this.setJoined(joinName, join);\n        return join;\n      });\n\n      return callback.apply(this, [null].concat(joins));\n\n    });\n\n  };\n\n  /**\n  * Creates a plain object from the Model, with properties matching an optional interface\n  * @param {Array} arrInterface Interface to use for object creation\n  */\n  toObject(arrInterface) {\n\n    let obj = {};\n\n    arrInterface = arrInterface ||\n      this.fieldList()\n      .concat(this._calculationsList)\n      .filter(key => !this._hides[key]);\n\n    arrInterface.forEach(key => {\n\n      if (this._hides[key]) {\n        return;\n      }\n\n      let joinObject;\n\n      if (typeof key === 'object' && key !== null) {\n        let subInterface = key;\n        key = Object.keys(key)[0];\n        joinObject = this._joinsCache[key];\n        joinObject && (obj[key] = joinObject.toObject(subInterface[key]));\n      } else if (this._data[key] !== undefined) {\n        obj[key] = this._data[key];\n      } else if (this._calculations[key] !== undefined) {\n        obj[key] = this.calculate(key);\n      } else if (joinObject = this._joinsCache[key]) {\n        obj[key] = joinObject.toObject();\n      }\n\n    });\n\n    return obj;\n\n  }\n\n  /**\n  * Get the table name for the model.\n  * @return {string}\n  */\n  tableName() {\n    return this._table;\n  }\n\n  /**\n  * Determine if the model has a specified field.\n  * @param {string} field\n  * @return {boolean}\n  */\n  hasField(field) {\n    return !!this._columnLookup[field];\n  }\n\n  /**\n  * Retrieve the schema field data for the specified field\n  * @param {string} field\n  * @return {Object}\n  */\n  getFieldData(field) {\n    return this._columnLookup[field];\n  }\n\n  /**\n  * Retrieve the schema data type for the specified field\n  * @param {string} field\n  * @return {string}\n  */\n  getDataTypeOf(field) {\n    return DataTypes[this._columnLookup[field].type];\n  }\n\n  /**\n  * Determine whether or not this field is an Array (PostgreSQL supports this)\n  * @param {string} field\n  * @return {boolean}\n  */\n  isFieldArray(field) {\n    let fieldData = this._columnLookup[field];\n    return !!(fieldData && fieldData.properties && fieldData.properties.array);\n  }\n\n  /**\n  * Determine whether or not this field is a primary key in our schema\n  * @param {string} field\n  * @return {boolean}\n  */\n  isFieldPrimaryKey(field) {\n    let fieldData = this._columnLookup[field];\n    return !!(fieldData && fieldData.properties && fieldData.properties.primary_key);\n  }\n\n  /**\n  * Retrieve the defaultValue for this field from our schema\n  * @param {string} field\n  * @return {any}\n  */\n  fieldDefaultValue(field) {\n    let fieldData = this._columnLookup[field];\n    return fieldData && fieldData.properties ? fieldData.properties.defaultValue : null;\n  }\n\n  /**\n  * Retrieve an array of fields for our model\n  * @return {Array}\n  */\n  fieldList() {\n    return this._columnNames.slice();\n  }\n\n  /**\n  * Retrieve our field schema definitions\n  * @return {Array}\n  */\n  fieldDefinitions() {\n    return this._columns.slice();\n  }\n\n  /**\n  * Set an error for a specified field (supports multiple errors)\n  * @param {string} key The specified field for which to create the error (or '*' for generic)\n  * @param {string} message The error message\n  * @return {boolean}\n  */\n  setError(key, message) {\n    this._errors[key] = this._errors[key] || [];\n    this._errors[key].push(message);\n    return true;\n  }\n\n  /**\n  * Clears all errors for a specified field\n  * @param {string} key The specified field for which to create the error (or '*' for generic)\n  * @return {boolean}\n  */\n  clearError(key) {\n    delete this._errors[key];\n    return true;\n  }\n\n  __generateSaveQuery__() {\n\n    let query, columns;\n    let db = this.db;\n\n    if (!this.inStorage()) {\n\n      columns = this.fieldList().filter(v => !this.isFieldPrimaryKey(v) && this.get(v) !== undefined);\n      query = db.adapter.generateInsertQuery(this.schema.table, columns);\n\n    } else {\n\n      columns = ['id'].concat(this.changedFields().filter(v => !this.isFieldPrimaryKey(v)));\n      query = db.adapter.generateUpdateQuery(this.schema.table, columns);\n\n    }\n\n    return {\n      sql: query,\n      params: columns.map(v => db.adapter.sanitize(this.getFieldData(v).type, this.get(v)))\n    };\n\n  }\n\n  /**\n  * Logic to execute before a model saves. Intended to be overwritten when inherited.\n  * @param {Function} callback Invoke with first argument as an error if failure.\n  */\n  beforeSave(callback) {\n\n    callback(null, this);\n\n  }\n\n  /**\n  * Logic to execute after a model saves. Intended to be overwritten when inherited.\n  * @param {Function} callback Invoke with first argument as an error if failure.\n  */\n  afterSave(callback) {\n\n    callback(null, this);\n\n  }\n\n  /**\n  * Save a model (execute beforeSave and afterSave)\n  * @param {Function} callback Callback to execute upon completion\n  */\n  save(callback) {\n\n    callback = callback || (() => {});\n\n    async.series([\n      this.__verify__,\n      this.beforeSave,\n      this.__save__,\n      this.afterSave\n    ].map(f => f.bind(this)), (err) => {\n      callback(err || null, this);\n    });\n\n  }\n\n  /**\n  * Runs an update query for this specific model instance\n  * @param {Object} fields Key-value pairs of fields to update\n  * @param {Function} callback Callback to execute upon completion\n  */\n  update(fields, callback) {\n\n    callback = callback || (() => {});\n\n    this.constructor.query()\n      .where({id: this.get('id')})\n      .update(fields, (err, models) => callback(err, models && models[0]));\n\n  }\n\n  /**\n  * Runs all verifications before saving\n  * @param {function} callback Method to execute upon completion. Returns true if OK, false if failed\n  * @private\n  */\n  __verify__(callback) {\n\n    // Run through verifications in order they were added\n    async.series(\n      this._verificationsList.map(verification => {\n        return callback => {\n          verification.action.apply(\n            this,\n            verification.fields\n              .map(field => this.get(field))\n              .concat(bool => {\n                if (bool) {\n                  callback(null);\n                } else {\n                  if (verification.field) {\n                    this.setError(verification.field, verification.message);\n                    callback(null);\n                  } else {\n                    callback(new Error(verification.message))\n                  }\n                }\n              })\n          )\n        };\n      }),\n      (err) => {\n\n        if (this.hasErrors()) {\n          return callback.call(this, this.errorObject());\n        } else if (err) {\n          return callback.call(this, err);\n        }\n\n        callback(null);\n\n      }\n    );\n\n  }\n\n  /**\n  * Saves model to database\n  * @param {function} callback Method to execute upon completion, returns error if failed (including validations didn't pass)\n  * @private\n  */\n  __save__(callback) {\n\n    let db = this.db;\n\n    // Legacy --- FIXME: Deprecated. Can remove for 1.0\n    if (arguments.length === 2) {\n      db = arguments[0];\n      callback = arguments[1];\n    }\n\n    if(typeof callback !== 'function') {\n      callback = function() {};\n    }\n\n    if (this.fieldList().indexOf('updated_at') !== -1) {\n      this.set('updated_at', new Date());\n    }\n\n    let query = this.__generateSaveQuery__();\n\n    db.query(\n      query.sql,\n      query.params,\n      (err, result) => {\n\n        if (err) {\n          this.setError('_query', err.message);\n        } else {\n          result.rows.length && this.__load__(result.rows[0], true);\n        }\n\n        callback.call(this, this.errorObject());\n\n      }\n    );\n\n  }\n\n  /**\n  * Destroys model and cascades all deletes.\n  * @param {function} callback method to run upon completion\n  */\n  destroyCascade(callback) {\n\n    ModelArray.from([this]).destroyCascade(callback);\n\n  }\n\n  /**\n  * Logic to execute before a model gets destroyed. Intended to be overwritten when inherited.\n  * @param {Function} callback Invoke with first argument as an error if failure.\n  */\n  beforeDestroy(callback) {\n\n    callback(null, this);\n\n  }\n\n  /**\n  * Logic to execute after a model is destroyed. Intended to be overwritten when inherited.\n  * @param {Function} callback Invoke with first argument as an error if failure.\n  */\n  afterDestroy(callback) {\n\n    callback(null, this);\n\n  }\n\n  /**\n  * Destroys model reference in database.\n  * @param {function({Error} err, {Nodal.Model} model)} callback\n  *   Method to execute upon completion, returns error if failed\n  */\n  destroy(callback) {\n\n    callback = callback || (() => {});\n\n    async.series([\n      this.beforeDestroy,\n      this.__destroy__,\n      this.afterDestroy\n    ].map(f => f.bind(this)), (err) => {\n      callback(err || null, this);\n    });\n\n  }\n\n  /**\n  * Destroys model reference in database\n  * @param {function} callback Method to execute upon completion, returns error if failed\n  * @private\n  */\n  __destroy__(callback) {\n\n    let db = this.db;\n\n    // Legacy\n    if (arguments.length === 2) {\n      db = arguments[0];\n      callback = arguments[1];\n    }\n\n    let model = this;\n\n    if (!(db instanceof Database)) {\n      throw new Error('Must provide a valid Database to save to');\n    }\n\n    if (typeof callback !== 'function') {\n      callback = function() {};\n    }\n\n    if (!model.inStorage()) {\n\n      setTimeout(callback.bind(model, {'_query': 'Model has not been saved'}, model), 1);\n      return;\n\n    }\n\n    let columns = model.fieldList().filter(function(v) {\n      return model.isFieldPrimaryKey(v);\n    });\n\n    let query = db.adapter.generateDeleteQuery(model.schema.table, columns);\n\n    db.query(\n      query,\n      columns.map(function(v) {\n        return db.adapter.sanitize(model.getFieldData(v).type, model.get(v, true));\n      }),\n      function(err, result) {\n\n        if (err) {\n          model.setError('_query', err.message);\n        } else {\n          model._inStorage = false;\n        }\n\n        callback.call(model, err, model);\n\n      }\n    );\n\n  }\n\n}\n\nModel.prototype.schema = {\n  table: '',\n  columns: []\n};\n\nModel.prototype._validations = {};\nModel.prototype._validationsList = [];\n\nModel.prototype._calculations = {};\nModel.prototype._calculationsList = [];\n\nModel.prototype._verificationsList = [];\n\nModel.prototype._hides = {};\n\nModel.prototype.data = null;\n\nModel.prototype.db = null;\n\nModel.prototype.externalInterface = [\n  'id',\n  'created_at',\n  'updated_at'\n];\n\nModel.prototype.aggregateBy = {\n  'id': 'count',\n  'created_at': 'min',\n  'updated_at': 'min'\n};\n\nmodule.exports = Model;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/required/db/data_types.js":"'use strict';\n\nmodule.exports = {\n  serial: {\n    convert: function(v) {\n      return Math.max(Math.min(parseInt(v) || 0, Number.MAX_SAFE_INTEGER), Number.MIN_SAFE_INTEGER);\n    }\n  },\n  int: {\n    convert: function(v) {\n      return Math.max(Math.min(parseInt(v) || 0, Number.MAX_SAFE_INTEGER), Number.MIN_SAFE_INTEGER);\n    }\n  },\n  currency: {\n    convert: function(v) {\n      return Math.max(Math.min(parseInt(v) || 0, Number.MAX_SAFE_INTEGER), Number.MIN_SAFE_INTEGER);\n    }\n  },\n  float: {\n    convert: function(v) {\n      return parseFloat(v) || 0;\n    }\n  },\n  string: {\n    convert: function(v) {\n      return v === null ? '' : (v + '');\n    }\n  },\n  text: {\n    convert: function(v) {\n      return v === null ? '' : (v + '');\n    }\n  },\n  datetime: {\n    convert: function(v) {\n      if(!(v instanceof Date)) {\n        v = new Date(v);\n        if(v.toString() === 'Invalid Date') {\n          v = new Date(0);\n        }\n      }\n      return v;\n    }\n  },\n  boolean: {\n    convert: function(v) {\n      return typeof v === 'string' ? [true, false][({'f':1,'false':1,'n':1,'no':1,'off':1,'0':1,'':1}[v]|0)] : !!v;\n    }\n  },\n  json: {\n    convert: function(v) {\n      return typeof v === 'string' ? JSON.parse(v) : v;\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/required/db/database.js":"'use strict';\n\nconst colors = require('colors/safe');\n\nconst DEFAULT_ADAPTER = 'postgres';\nconst ADAPTERS = {\n  'postgres': './adapters/postgres.js',\n};\n\nclass Database {\n\n  constructor() {\n\n    this.adapter = null;\n    this._useLogColor = 0;\n\n  }\n\n  connect(cfg) {\n\n    if (typeof cfg === 'string') {\n      cfg = {connectionString: cfg};\n    }\n\n    const Adapter = require(ADAPTERS[cfg.adapter] || ADAPTERS[DEFAULT_ADAPTER]);\n    this.adapter = new Adapter(this, cfg);\n\n    return true;\n\n  }\n\n  close(callback) {\n\n    this.adapter.close.apply(this, arguments);\n    callback && callback.call(this);\n    return true;\n\n  }\n\n  log(sql, params, time) {\n\n    let colorFunc = this.__logColorFuncs[this._useLogColor];\n\n    console.log();\n    console.log(colorFunc(sql));\n    params && console.log(colorFunc(JSON.stringify(params)));\n    time && console.log(colorFunc(time + 'ms'));\n    console.log();\n\n    this._useLogColor = (this._useLogColor + 1) % this.__logColorFuncs.length;\n\n    return true;\n\n  }\n\n  info(message) {\n\n    console.log(colors.green.bold('Database Info: ') + message);\n\n  }\n\n  error(message) {\n\n    console.log(colors.red.bold('Database Error: ') + message);\n    return true;\n\n  }\n\n  query() {\n\n    this.adapter.query.apply(this.adapter, arguments);\n\n  }\n\n  transaction() {\n\n    this.adapter.transaction.apply(this.adapter, arguments);\n\n  }\n\n  drop() {\n\n    this.adapter.drop.apply(this.adapter, arguments);\n\n  }\n\n  create() {\n\n    this.adapter.create.apply(this.adapter, arguments);\n\n  }\n\n}\n\nDatabase.prototype.__logColorFuncs = [\n  (str) => {\n    return colors.yellow.bold(str);\n  },\n  (str) => {\n    return colors.white(str);\n  }\n];\n\nmodule.exports = Database;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/required/composer.js":"'use strict';\n\nconst ItemArray = require('./item_array.js');\nconst ModelArray = require('./model_array.js');\nconst Transaction = require('./db/transaction.js');\n\nconst utilities = require('./utilities.js');\n\n/**\n* The query composer (ORM)\n* @class\n*/\nclass Composer {\n\n  /**\n  * Created by Model#query, used for composing SQL queries based on Models\n  * @param {Nodal.Model} Model The model class the composer is querying from\n  * @param {Nodal.Composer} [parent=null] The composer's parent (another composer instance)\n  */\n  constructor(Model, parent) {\n\n    this.db = Model.prototype.db;\n    this.Model = Model;\n\n    this._parent = parent || null;\n    this._command = null;\n    this._transaction = null;\n\n  }\n\n  /**\n  * Given rows with repeated data (due to joining in multiple children), return only parent models (but include references to their children)\n  * @param {Array} rows Rows from sql result\n  * @param {Boolean} grouped Are these models grouped, if so, different procedure\n  * @return {Nodal.ModelArray}\n  * @private\n  */\n  __parseModelsFromRows__(rows, grouped) {\n\n    if (grouped) {\n      return ItemArray.from(rows);\n    }\n\n    if (!rows.length) {\n      return new ModelArray(this.Model);\n    }\n\n    let keys = Object.keys(rows[0]);\n    let cache = {};\n    let mainCache = {};\n    cache[this.Model.name] = mainCache;\n\n    let columns = keys\n      .filter(k => k[0] !== '$');\n\n    let columnsObject = columns\n      .reduce((columns, k) => {\n\n        columns[k] = null;\n        return columns;\n\n      }, {});\n\n    let joinsObject = keys\n      .filter(k => k[0] === '$')\n      .reduce((joinsObject, k) => {\n\n        let mid = k.indexOf('$', 1);\n        let name = k.substring(1, mid)\n        let field = k.substring(mid + 1);\n        let relationship = this.Model.relationship(name);\n\n        joinsObject[name] = joinsObject[name] || {};\n\n        let rModel = relationship.getModel()\n        joinsObject[name].Model = rModel;\n        cache[rModel.name] = {};\n\n        joinsObject[name].name = name;\n        joinsObject[name].key = k;\n        joinsObject[name].multiple = relationship.immediateMultiple();\n\n        joinsObject[name].columns = joinsObject[name].columns || [];\n        joinsObject[name].columns.push(field);\n\n        joinsObject[name].columnsObject = joinsObject[name].columnsObject || {};\n        joinsObject[name].columnsObject[field] = null;\n\n        joinsObject[name].cachedModel = null;\n\n        return joinsObject;\n\n      }, {});\n\n    let joins = Object\n      .keys(joinsObject)\n      .sort((a, b) => a.length > b.length ? 1 : -1)\n      .map(k => joinsObject[k]);\n\n    let models = new ModelArray(this.Model);\n\n    rows.forEach(row => {\n\n      let model = mainCache[row.id];\n\n      if (!model) {\n\n        model = mainCache[row.id] = new this.Model(columns.reduce((obj, k) => {\n          obj[k] = row[k];\n          return obj;\n        }, columnsObject), true);\n\n        models.push(model);\n\n      }\n\n      joins.forEach(join => {\n\n        let id = row[`\\$${join.name}\\$id`];\n\n        let name = join.name;\n        let names = name.split('__');\n        let joinName = names.pop();\n        let parentName = names.join('__');\n\n        let parentModel = parentName ? joinsObject[parentName].cachedModel : model;\n\n        if (join.multiple) {\n          parentModel && (parentModel.joined(joinName) || parentModel.setJoined(joinName, new ModelArray(join.Model)));\n        }\n\n        if (!id) {\n          return;\n        }\n\n        let joinCache = cache[join.Model.name];\n        let joinModel = join.cachedModel = joinCache[id];\n\n        if (!joinModel) {\n          joinModel = join.cachedModel = joinCache[id] = new join.Model(join.columns.reduce((obj, k) => {\n            obj[k] = row[`\\$${join.name}\\$${k}`];\n            return obj;\n          }, join.columnsObject), true)\n        }\n\n\n        if (join.multiple) {\n          let modelArray = parentModel.joined(joinName);\n          !modelArray.has(joinModel) && modelArray.push(joinModel);\n        } else {\n          parentModel.joined(joinName) || parentModel.setJoined(joinName, joinModel);\n        }\n\n      });\n\n    });\n\n    return models;\n\n  }\n\n  /**\n  * Collapses linked list of queries into an array (for .reduce, .map etc)\n  * @return {Array}\n  * @private\n  */\n  __collapse__() {\n\n    let composerArray = [];\n    let composer = this;\n\n    while (composer) {\n      composerArray.unshift(composer);\n      composer = composer._parent;\n    }\n\n    return composerArray;\n\n  }\n\n  /**\n  * Removes last limit command from a collapsed array of composer commands\n  * @param {Array} [composerArray] Array of composer commands\n  * @return {Array}\n  * @private\n  */\n  __removeLastLimitCommand__(composerArray) {\n\n    let found = composerArray.map(c => c._command && c._command.type).lastIndexOf('limit');\n    (found !== -1) && composerArray.splice(found, 1);\n    return composerArray;\n\n  }\n\n  /**\n  * Gets last limit command from a collapsed array of composer commands\n  * @param {Array} [composerArray] Array of composer commands\n  * @return {Array}\n  * @private\n  */\n  __getLastLimitCommand__(composerArray) {\n\n    let found = composerArray.map(c => c._command && c._command.type).lastIndexOf('limit');\n    return found >= 0 ? composerArray.splice(found, 1)[0] : null;\n\n  }\n\n  /**\n  * Determines whether this composer query represents a grouped query or not\n  * @return {Boolean}\n  * @private\n  */\n  __isGrouped__() {\n    return this.__collapse__().filter(c => c._command && c._command.type === 'groupBy').length > 0;\n  }\n\n  /**\n  * Reduces an array of composer queries to a single query information object\n  * @param {Array} [composerArray]\n  * @return {Object} Looks like {commands: [], joins: []}\n  * @private\n  */\n  __reduceToQueryInformation__(composerArray) {\n\n    let joins = {};\n\n    let commands = composerArray.reduce((p, c) => {\n\n      let composerCommand = c._command || {type: 'where', data: {comparisons: []}};\n\n      if (composerCommand.type === 'join') {\n\n        let curJoinName = composerCommand.data.name;\n        let curJoinData = composerCommand.data.joinData;\n        joins[curJoinName] = curJoinData;\n        Object.keys(joins)\n          .filter(joinName => joinName !== curJoinName)\n          .forEach(joinName => {\n\n            if (curJoinName.indexOf(joinName) === 0) {\n              joins[curJoinName] = joins[joinName].concat(curJoinData.slice(joins[joinName].length));\n              delete joins[joinName];\n            } else if (joinName.indexOf(curJoinName) === 0) {\n              joins[joinName][curJoinData.length - 1] = curJoinData[curJoinData.length - 1];\n              delete joins[curJoinName];\n            }\n\n          });\n\n        return p;\n\n      }\n\n      let lastCommand = p[p.length - 1];\n      let command = {\n        where: null,\n        limit: null,\n        orderBy: [],\n        groupBy: [],\n        aggregate: []\n      };\n      p.push(command);\n\n      if (\n        lastCommand && (\n          !lastCommand[composerCommand.type] ||\n          lastCommand[composerCommand.type] instanceof Array\n        )\n      ) {\n\n        command = lastCommand;\n        p.pop();\n\n      }\n\n      if (command[composerCommand.type] instanceof Array) {\n\n        command[composerCommand.type].push(\n          Object.keys(composerCommand.data).reduce((p, c) => {\n            return (p[c] = composerCommand.data[c], p);\n          }, {})\n        );\n\n      } else {\n\n        command[composerCommand.type] = Object.keys(composerCommand.data).reduce((p, c) => {\n          return (p[c] = composerCommand.data[c], p);\n        }, {});\n\n      }\n\n      return p;\n\n    }, []);\n\n    return {\n      commands: commands,\n      joins: joins\n    }\n\n  }\n\n  /**\n  * Reduces an array of commands from query informtion to a SQL query\n  * @param {Array} [commandArray]\n  * @param {Array} [includeColumns=*] Which columns to include, includes all by default\n  * @return {Object} Looks like {sql: [], params: []}\n  * @private\n  */\n  __reduceCommandsToQuery__(commandArray, includeColumns) {\n\n    let lastAggregate = null;\n\n    return commandArray.reduce((prev, command, i) => {\n\n      if (command.aggregate.length && command.groupBy.length) {\n        lastAggregate = command.aggregate;\n      }\n\n      let table = `t${i}`;\n\n      let multiFilter = this.db.adapter.createMultiFilter(table, command.where ? command.where.comparisons : []);\n      let params = this.db.adapter.getParamsFromMultiFilter(multiFilter);\n\n      let joins = null;\n      let columns = includeColumns || lastAggregate || this.Model.columnNames();\n\n      columns = columns\n        .map(c => typeof c !== 'string' ? c : {columnNames: [c], alias: c, transformation: v => v})\n        .map(c => Object.keys(c).reduce((p, k) => { return (p[k] = c[k], p); }, {}));\n\n      !command.groupBy.length && columns.forEach(c => {\n        c.transformation = v => v;\n        c.columnNames = [c.alias];\n      });\n\n      return {\n        sql: this.db.adapter.generateSelectQuery(\n          prev.sql || {table: this.Model.table()},\n          table,\n          columns,\n          multiFilter,\n          joins,\n          command.groupBy,\n          command.orderBy,\n          command.limit,\n          prev.params.length\n        ),\n        params: prev.params.concat(params)\n      }\n\n    }, {sql: null, params: []});\n\n  }\n\n  /**\n  * Retrieve all joined column data for a given join\n  * @param {string} joinName The name of the join relationship\n  * @private\n  */\n  __joinedColumns__(joinName) {\n    let relationship = this.Model.relationships().findExplicit(joinName);\n    return relationship.getModel().columnNames().map(columnName => {\n      return {\n        name: joinName,\n        table: relationship.getModel().table(),\n        columnNames: [columnName],\n        alias: `\\$${joinName}\\$${columnName}`,\n        transformation: v => v\n      };\n    });\n  }\n\n  /**\n  * Generate a SQL query and its associated parameters from the current composer instance\n  * @param {Array} [includeColumns=*] Which columns to include, includes all by default\n  * @param {boolean} [disableJoins=false] Disable joins if you just want a subset of data\n  * @return {Object} Has \"params\" and \"sql\" properties.\n  * @private\n  */\n  __generateQuery__(includeColumns, disableJoins) {\n\n    disableJoins = disableJoins || this.__isGrouped__();\n\n    let queryInfo = this.__reduceToQueryInformation__(this.__collapse__());\n    let query = this.__reduceCommandsToQuery__(queryInfo.commands, includeColumns);\n\n    return disableJoins ? query : this.__addJoinsToQuery__(\n      query,\n      queryInfo,\n      includeColumns\n    );\n\n  }\n\n  /**\n  * Generate a SQL count query\n  * @param {boolean} [useLimit=false] Generates COUNT using limit command as well\n  * @return {Object} Has \"params\" and \"sql\" properties.\n  * @private\n  */\n  __generateCountQuery__(useLimit) {\n\n    let collapsed = this.__collapse__();\n    collapsed = useLimit ? collapsed : this.__removeLastLimitCommand__(collapsed);\n    let queryInfo = this.__reduceToQueryInformation__(collapsed);\n    let query = this.__reduceCommandsToQuery__(queryInfo.commands);\n    query.sql = this.db.adapter.generateCountQuery(query.sql, 'c');\n    return query;\n\n  }\n\n  /**\n  * Generate a SQL update query\n  * @param {Object} [fields] A list of field / value pairs to set\n  * @return {Object} has \"params\" and \"sql\" properties\n  * @private\n  */\n  __generateUpdateQuery__(fields) {\n\n    let query = this.__generateQuery__(['id'], true);\n    let columns = Object.keys(fields);\n    let params = columns.map(c => fields[c]);\n\n    let columnNames = columns.filter((v, i) => typeof params[i] !== 'function');\n    let columnFunctions = columns\n      .filter((v, i) => typeof params[i] === 'function')\n      .map((v, i) => [v, utilities.getFunctionParameters(params[i]), params[i]]);\n\n    params = params.filter(v => typeof v !== 'function');\n\n    query.sql = this.db.adapter.generateUpdateAllQuery(\n      this.Model.table(),\n      'id',\n      columnNames,\n      columnFunctions,\n      query.params.length,\n      query.sql\n    );\n\n    query.params = query.params.concat(params);\n\n    return query;\n\n  }\n\n  /**\n  * Add Joins to a query from queryInfo\n  * @param {Object} query Must be format {sql: '', params: []}\n  * @param {Object} queryInfo Must be format {commands: [], joins: []}\n  * @param {Array} [includeColumns=*] Which columns to include, includes all by default\n  * @return {Object} Has \"params\" and \"sql\" properties.\n  * @private\n  */\n  __addJoinsToQuery__(query, queryInfo, includeColumns) {\n\n    let columns = includeColumns || this.Model.columnNames();\n\n    let joins = queryInfo.joins;\n\n    Object.keys(joins).forEach(joinName => {\n      joins[joinName].forEach(j => {\n        columns = columns.concat(this.__joinedColumns__(j.joinAlias));\n      });\n    });\n\n    joins = Object.keys(joins).map(k => joins[k]);\n    let params = query.params.slice();\n\n    joins.forEach(join => {\n\n      join.forEach(j => {\n        params = params.concat(this.db.adapter.getParamsFromMultiFilter(j.multiFilter));\n      });\n\n    });\n\n    // Set join OrderBys... in reverse order\n    let orderBy = queryInfo.commands.reduce((arr, command) => {\n      command.orderBy && (arr = command.orderBy.concat(arr));\n      return arr;\n    }, []);\n\n    // When doing joins, we count paramOffset as the last where parameter length\n    // Because we add in a bunch of parameters at the end.\n\n    return {\n      sql: this.db.adapter.generateSelectQuery(\n        query.sql,\n        'j',\n        columns,\n        null,\n        joins,\n        null,\n        orderBy,\n        null,\n        query.params.length\n      ),\n      params: params\n    };\n\n  }\n\n  /**\n  * When using Composer#where, format all provided comparisons\n  * @param {Object} comparisons Comparisons object. {age__lte: 27}, for example.\n  * @param {Nodal.Model} Model the model to use as the basis for comparison. Default to current model.\n  * @return {Array}\n  * @private\n  */\n  __parseComparisons__(comparisons, Model) {\n\n    Model = Model || this.Model;\n\n    let comparators = this.db.adapter.comparators;\n    let columnLookup = Model.columnLookup();\n\n    return Object.keys(comparisons)\n      .map(comparison => {\n\n        let column = comparison.split('__');\n        let rel = null;\n        let joinName;\n\n        let comparator = column.pop();\n        if (!comparators[comparator]) {\n          column.push(comparator);\n          comparator = 'is';\n        }\n\n        if (column.length > 1) {\n          joinName = column.slice(0, column.length - 1).join('__');\n          rel = Model.relationship(joinName);\n          column = column.slice(column.length - 1);\n        }\n\n        let table = null;\n        let joined = false;\n        let joins = null;\n\n        if (rel) {\n\n          // if it's not found, return null...\n          if (!rel.getModel().hasColumn(column[0])) {\n            return null;\n          }\n\n          table = rel.getModel().table();\n          joined = true;\n          joins = rel.joins('w');\n\n        }\n\n        let columnName = column[0];\n\n        // block out bad column names\n        if (!rel && !Model.hasColumn(columnName)) {\n          return null;\n        }\n\n        return {\n          table: table,\n          columnName: columnName,\n          comparator: comparator,\n          value: comparisons[comparison],\n          joined: joined,\n          joins: joins\n        };\n\n      })\n      .filter(v => {\n        return !!v;\n      });\n\n  }\n\n  __filterHidden__(Model, comparisonsArray) {\n\n    comparisonsArray = (comparisonsArray || []).filter(c => c);\n\n    let comparators = this.db.adapter.comparators;\n\n    return comparisonsArray.map(comparisons => {\n\n      Object.keys(comparisons).forEach(comparison => {\n\n        let cModel = Model;\n\n        let column = comparison.split('__');\n        let comparator = column.pop();\n        !comparators[comparator] && column.push(comparator);\n        let field = column.pop();\n        let relName = column.join('__');\n        if (relName) {\n          let rel = cModel.relationship(relName);\n          if (!rel) {\n            return;\n          }\n          cModel = rel.getModel();\n        }\n\n        if (cModel.isHidden(field)) {\n          delete comparisons[comparison];\n        }\n\n      });\n\n      if (Object.keys(comparisons).length === 0) {\n        return null;\n      }\n\n      return comparisons;\n\n    }).filter(comparisons => comparisons);\n\n  }\n\n  /**\n  * Add comparisons to SQL WHERE clause. Does not allow filtering if Model.hides() has been called.\n  * @param {Object} comparisons Comparisons object. {age__lte: 27}, for example.\n  * @return {Nodal.Composer} new Composer instance\n  */\n  safeWhere(comparisonsArray) {\n\n    if (!(comparisonsArray instanceof Array)) {\n      comparisonsArray = [].slice.call(arguments);\n    }\n\n    return this.where(\n      this.__filterHidden__(\n        this.Model,\n        comparisonsArray\n      )\n    );\n\n  }\n\n  /**\n  * Join in a relationship. Filters out hidden fields from comparisons.\n  * @param {string} joinName The name of the joined relationship\n  * @param {array} comparisonsArray comparisons to perform on this join (can be overloaded)\n  */\n  safeJoin(joinName, comparisonsArray) {\n\n    if (!(comparisonsArray instanceof Array)) {\n      comparisonsArray = [].slice.call(arguments, 1);\n    }\n\n    let relationship = this.Model.relationship(joinName);\n    if (!relationship) {\n      return this;\n    }\n\n    return this.join(\n      joinName,\n      this.__filterHidden__(\n        relationship.getModel(),\n        comparisonsArray\n      )\n    );\n\n  }\n\n  /**\n  * Add comparisons to SQL WHERE clause.\n  * @param {Object} comparisons Comparisons object. {age__lte: 27}, for example.\n  * @return {Nodal.Composer} new Composer instance\n  */\n  where(comparisonsArray) {\n\n    if (!(comparisonsArray instanceof Array)) {\n      comparisonsArray = [].slice.call(arguments);\n    }\n\n    comparisonsArray = comparisonsArray.map(comparisons => {\n      return Object.keys(comparisons).reduce((p, c) => { return (p[c] = comparisons[c], p); }, {});\n    });\n\n    let order = null;\n    let offset = null;\n    let count = null;\n\n    comparisonsArray.forEach(comparisons => {\n\n      if ('__order' in comparisons) {\n        order = comparisons.__order.split(' ');\n        delete comparisons.__order;\n      }\n\n      if ('__offset' in comparisons || '__count' in comparisons) {\n        offset = comparisons.__offset;\n        count = comparisons.__count;\n        delete comparisons.__offset;\n        delete comparisons.__count;\n      }\n\n    });\n\n    if (order || offset || count) {\n      let composer = this;\n      order && (composer = composer.orderBy(order[0], order[1]));\n      (offset || count) && (composer = composer.limit(offset || 0, count || 0));\n      return composer.where(comparisonsArray);\n    }\n\n    this._command = {\n      type: 'where',\n      data: {\n        comparisons: comparisonsArray\n        .map(comparisons => this.__parseComparisons__(comparisons))\n        .filter(f => f.length)\n      }\n    };\n\n    return new Composer(this.Model, this);\n\n  }\n\n  /**\n  * Order by field belonging to the current Composer instance's model.\n  * @param {string} field Field to order by\n  * @param {string} direction Must be 'ASC' or 'DESC'\n  * @return {Nodal.Composer} new Composer instance\n  */\n  orderBy(field, direction) {\n\n    let transformation;\n    let fields = [];\n\n    if (typeof field === 'function') {\n      fields = utilities.getFunctionParameters(field);\n      transformation = field;\n    } else {\n      fields = [field];\n      transformation = v => `${v}`;\n    }\n\n    fields.forEach(field => {\n      if (!this.Model.hasColumn(field)) {\n        throw new Error(`Cannot order by ${field}, it does not belong to ${this.Model.name}`);\n      }\n    });\n\n    this._command = {\n      type: 'orderBy',\n      data: {\n        columnNames: fields,\n        transformation: transformation,\n        direction: ({'asc': 'ASC', 'desc': 'DESC'}[(direction + '').toLowerCase()] || 'ASC')\n      }\n    };\n\n    return new Composer(this.Model, this);\n\n  }\n\n  /**\n  * Limit to an offset and count\n  * @param {number} offset The offset at which to set the limit. If this is the only argument provided, it will be the count instead.\n  * @param {number} count The number of results to be returned. Can be omitted, and if omitted, first argument is used for count.\n  * @return {Nodal.Composer} new Composer instance\n  */\n  limit(offset, count) {\n\n    if (this._command) {\n      return new Composer(this.Model, this).limit(offset, count);\n    }\n\n    if (count === undefined) {\n      count = offset;\n      offset = 0;\n    }\n\n    count = parseInt(count);\n    offset = parseInt(offset);\n\n    this._command = {\n      type: 'limit',\n      data: {\n        count: count,\n        offset: offset\n      }\n    };\n\n    return new Composer(this.Model, this);\n\n  }\n\n  /**\n  * Join in a relationship.\n  * @param {string} joinName The name of the joined relationship\n  * @param {array} comparisonsArray comparisons to perform on this join (can be overloaded)\n  */\n  join(joinName, comparisonsArray, orderBy, count, offset) {\n\n    // FIXME: validate orderBy\n    orderBy = orderBy || '';\n    count = Math.max(0, count | 0);\n    offset = Math.max(0, offset | 0);\n\n    if (!(comparisonsArray instanceof Array)) {\n      comparisonsArray = [].slice.call(arguments, 1);\n    }\n\n    let relationship = this.Model.relationships().findExplicit(joinName);\n    if (!relationship) {\n      throw new Error(`Model ${this.Model.name} does not have relationship \"${joinName}\".`);\n    }\n\n    let composer = this;\n    while (composer) {\n      if (composer._command && composer._command.type === 'join' && composer._command.data.name === joinName) {\n        return this;\n      }\n      composer = composer._parent;\n    }\n\n    let joinData = relationship.joins();\n    joinData[joinData.length - 1].joinAlias = joinName;\n    joinData[joinData.length - 1].prevAlias = joinName.split('__').slice(0, -1).join('__');\n    joinData[joinData.length - 1].multiFilter = this.db.adapter.createMultiFilter(\n      joinName,\n      comparisonsArray\n        .map(comparisons => this.__parseComparisons__(comparisons, relationship.getModel()))\n        .filter(f => f.length)\n    );\n\n    // FIXME: implement properly\n    joinData[joinData.length - 1].orderBy = orderBy;\n    joinData[joinData.length - 1].offset = offset;\n    joinData[joinData.length - 1].count = count;\n\n    this._command = {\n      type: 'join',\n      data: {\n        name: joinName,\n        joinData: joinData\n      }\n    };\n\n    return new Composer(this.Model, this);\n\n  }\n\n  /**\n  * Groups by a specific field, or a transformation on a field\n  * @param {String} column The column to group by\n  */\n  groupBy(column) {\n\n    let columns;\n    let transformation;\n\n    if (typeof column === 'function') {\n      columns = utilities.getFunctionParameters(column);\n      transformation = column;\n    } else {\n      columns = [column];\n      transformation = v => `${v}`;\n    }\n\n    this._command = {\n      type: 'groupBy',\n      data: {\n        columnNames: columns,\n        transformation: transformation\n      }\n    };\n\n    return new Composer(this.Model, this).aggregate(column);\n\n  }\n\n  /**\n  * Aggregates a field\n  * @param {String} alias The alias for the new aggregate field\n  * @param {Function} transformation The transformation to apply to create the aggregate\n  */\n  aggregate(alias, transformation) {\n\n    let columns;\n\n    if (typeof alias === 'function') {\n      columns = utilities.getFunctionParameters(alias);\n      transformation = alias;\n      alias = columns.join('___');\n    } else if (typeof transformation === 'function') {\n      columns = utilities.getFunctionParameters(transformation);\n    } else {\n      columns = [alias]\n      transformation = v => v;\n    }\n\n    this._command = {\n      type: 'aggregate',\n      data: {\n        alias: alias,\n        columnNames: columns,\n        transformation: transformation\n      }\n    };\n\n    return new Composer(this.Model, this);\n\n  }\n\n  /**\n  * Counts the results in the query\n  * @param {function} callback Supplied with an error and the integer value of the count\n  */\n  count(callback) {\n\n    let countQuery = this.__generateCountQuery__(true);\n\n    this.db.query(countQuery.sql, countQuery.params, (err, result) => {\n\n      callback(err, (((result && result.rows) || [])[0] || {}).__total__ || 0);\n\n    });\n\n  }\n\n  /**\n  * Processes results and errors from a terminal call\n  * @private\n  */\n  __endProcessor__(err, r, callback) {\n\n    if (!r || !r.countResult || !r.result) {\n      throw new Error('End Query Expects object containing \"count\" and \"results\"');\n    }\n\n    let limitCommand = this.__getLastLimitCommand__(this.__collapse__());\n    let offset = limitCommand ? limitCommand._command.data.offset : 0;\n\n    let total = (((r.countResult && r.countResult.rows) || [])[0] || {}).__total__ || 0;\n    let rows = r.result ? (r.result.rows || []).slice() : [];\n    let models = this.__parseModelsFromRows__(rows, this.__isGrouped__());\n\n    if (r.updateResult && r.updateResult.rows) {\n\n      let cache = r.updateResult.rows.reduce((cache, obj) => {\n        cache[obj.id] = obj;\n        return cache;\n      }, {});\n\n      models.forEach(m => {\n        let data = cache[m.get('id')];\n        data && m.read(data);\n      });\n\n    }\n\n    models.setMeta({offset: offset, total: total});\n    callback.call(this, err, models);\n\n  }\n\n  /**\n  * Sets the top-level query as a transaction using provided txn\n  * @param {Transaction} txn The desired transaction to use\n  * @return self\n  */\n  transact(txn) {\n\n    if (!txn) {\n      return this;\n    }\n\n    if (!(txn instanceof Transaction)) {\n      throw new Error('Must provide valid transaction to Composer#transact');\n    }\n\n    if (txn.adapter.db !== this.db) {\n      throw new Error('Transaction must belong to Model Database');\n    }\n\n    this._transaction = txn;\n    return this;\n\n  }\n\n  /**\n  * Execute the query you've been composing.\n  * @param {function({Error}, {Nodal.ModelArray})} callback The method to execute when the query is complete\n  */\n  end(callback) {\n\n    let query = this.__generateQuery__();\n    let countQuery = this.__generateCountQuery__();\n\n    let source = this._transaction ? this._transaction : this.db;\n\n    source.query(countQuery.sql, countQuery.params, (err, countResult) => {\n\n      source.query(query.sql, query.params, (err, result) => {\n\n        this.__endProcessor__(\n          err,\n          {\n            countResult: countResult || [],\n            result: result || []\n          },\n          callback\n        );\n\n      });\n\n    });\n\n  }\n\n  /**\n  * Shortcut for .limit(1).end(callback) that only returns a model object or error if not found\n  * @param {Function} callback Callback to execute, provides an error and model parameter\n  */\n  first(callback) {\n\n    return this.limit(1).end((err, models) => {\n\n      if (!err && !models.length) {\n        err = new Error(`No records for ${this.Model.name} found in your query`);\n      }\n\n      callback(err, models[0]);\n\n    });\n\n  }\n\n  /**\n  * Execute query as an update query, changed all fields specified.\n  * @param {Object} fields The object containing columns (keys) and associated values you'd like to update\n  * @param {function({Error}, {Nodal.ModelArray})} callback The callback for the update query\n  */\n  update(fields, callback) {\n\n    if (this.__isGrouped__()) {\n      throw new Error('Cannot update grouped queries');\n    }\n\n    let query = this.__generateQuery__();\n    let countQuery = this.__generateCountQuery__();\n    let updateQuery = this.__generateUpdateQuery__(fields);\n\n    let source = this._transaction ? this._transaction : this.db;\n\n    source.query(countQuery.sql, countQuery.params, (err, countResult) => {\n\n      source.query(query.sql, query.params, (err, result) => {\n\n        source.query(updateQuery.sql, updateQuery.params, (err, updateResult) => {\n\n          this.__endProcessor__(\n            err,\n            {\n              countResult: countResult || [],\n              result: result || [],\n              updateResult: updateResult || []\n            },\n            callback\n          );\n\n        });\n\n      });\n\n    });\n\n  }\n\n}\n\nmodule.exports = Composer;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/required/item_array.js":"'use strict';\n\nconst async = require('async');\n\n/**\n* Array of Items, for easy conversion to Objects\n* @class\n*/\nclass ItemArray extends Array {\n\n  /**\n  * Create the ItemArray\n  */\n  constructor() {\n\n    super();\n    this._meta = {\n      total: 0,\n      offset: 0\n    };\n\n  }\n\n  /**\n  * Convert a normal Array into a ItemArray\n  * @param {Array} arr The array of child objects\n  */\n  static from(arr) {\n\n    let itemArray = new this();\n    itemArray.push.apply(itemArray, arr);\n\n    return itemArray;\n\n  }\n\n  /**\n  * Sets metadata for the modelArray\n  * @param {Object} data values to set\n  */\n  setMeta(data) {\n\n    Object.keys(data).forEach(k => this._meta[k] = data[k]);\n    return this._meta;\n\n  }\n\n  /**\n  * Creates an Array of plain objects from the ModelArray, with properties matching an optional interface\n  * @param {Array} arrInterface Interface to use for object creation for each model\n  */\n  toObject(arrInterface) {\n\n    let keys = [];\n\n    if (this.length) {\n\n      keys = Object.keys(this[0]);\n\n      if (arrInterface && arrInterface.length) {\n        keys = keys.filter(k => (arrInterface.indexOf(k) !== -1));\n      }\n\n    }\n\n    return this.map(m => {\n      return keys.reduce((p, k) => {\n        p[k] = m[k];\n        return p;\n      }, {});\n    });\n\n  }\n\n}\n\nmodule.exports = ItemArray;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/required/model_array.js":"'use strict';\n\nconst async = require('async');\n\nconst ItemArray = require('./item_array.js');\n\n/**\n* Array of Models, for easy conversion to Objects\n* @class\n*/\nclass ModelArray extends ItemArray {\n\n  /**\n  * Create the ModelArray with a provided Model to use as a reference.\n  * @param {Array|class Nodal.Model} modelConstructor Must pass the constructor for the type of ModelArray you wish to create.\n  */\n  constructor(modelConstructor) {\n\n    super();\n    this.Model = modelConstructor;\n\n  }\n\n  /**\n  * Convert a normal Array into a ModelArray\n  * @param {Array} arr The array of child objects\n  */\n  static from(arr) {\n\n    if (!arr.length) {\n      throw new Error('Cannot create ModelArray from empty Array');\n    }\n\n    let modelArray = new this(arr[0].constructor);\n    modelArray.push.apply(modelArray, arr);\n\n    return modelArray;\n\n  }\n\n  /**\n  * Creates an Array of plain objects from the ModelArray, with properties matching an optional interface\n  * @param {Array} arrInterface Interface to use for object creation for each model\n  */\n  toObject(arrInterface) {\n\n    return Array.from(this).map(m => m.toObject(arrInterface));\n\n  }\n\n  /**\n  * Checks if ModelArray has a model in it\n  * @param {Nodal.Model} model\n  */\n  has(model) {\n    return this.filter(m => m.get('id') === model.get('id')).length > 0;\n  }\n\n  /**\n  * Calls Model#read on each Model in the ModelArray\n  * @param {Object}\n  */\n  readAll(data) {\n    this.forEach(model => model.read(data));\n    return true;\n  }\n\n  /**\n  * Calls Model#set on each Model in the ModelArray\n  * @param {string} field Field to set\n  * @param {any} value Value for the field\n  */\n  setAll(field, value) {\n    this.forEach(model => model.set(field, value));\n    return true;\n  }\n\n  /**\n  * Destroys (deletes) all models in the ModelArray from the database\n  * @param {function} callback Method to invoke upon completion\n  */\n  destroyAll(callback) {\n\n    if (this.filter(m => !m.inStorage()).length) {\n      return callback(new Error('Not all models are in storage'))\n    }\n\n    let db = this.Model.prototype.db;\n\n    let params = this.map(m => m.get('id'));\n    let sql = db.adapter.generateDeleteAllQuery(this.Model.table(), 'id', params);\n\n    db.query(\n      sql,\n      params,\n      (err, result) => {\n\n        if (err) {\n          return callback.call(this, new Error(err.message));\n        }\n\n        this.forEach(m => m._inStorage = false);\n\n        callback.call(this, null);\n\n      }\n    );\n\n  }\n\n  /**\n  * Destroys model and cascades all deletes.\n  * @param {function} callback method to run upon completion\n  */\n  destroyCascade(callback) {\n\n    let db = this.Model.prototype.db;\n\n    if (this.filter(m => !m.inStorage()).length) {\n      return callback(new Error('Not all models are in storage'))\n    }\n\n    let params = this.map(m => m.get('id'));\n    let txn = [[db.adapter.generateDeleteAllQuery(this.Model.table(), 'id', params), params]];\n\n    let children = this.Model.relationships().cascade();\n    txn = txn.concat(\n      children.map(p => {\n        return [db.adapter.generateDeleteAllQuery(p.getModel().table(), 'id', params, p.joins(null, this.Model.table())), params];\n      })\n    ).reverse();\n\n    db.transaction(\n      txn,\n      (err, result) => {\n\n        if (err) {\n          return callback(err);\n        }\n\n        this.forEach(m => m._inStorage = false);\n\n        callback(null);\n\n      }\n    );\n\n  }\n\n  /**\n  * Saves / updates all models in the ModelArray. Uses beforeSave / afterSave. Will return an error and rollback if *any* model errors out.\n  * @param {function} callback returning the error and reference to self\n  */\n  saveAll(callback) {\n\n    if (!this.length) {\n      return callback.call(this, null, this);\n    }\n\n    async.series(\n      this.map(m => m.beforeSave.bind(m)),\n      err => {\n\n        if (err) {\n          return callback(err);\n        }\n\n        this.__saveAll__(err => {\n\n          if (err) {\n            return callback(err, this);\n          }\n\n          async.series(\n            this.map(m => m.afterSave.bind(m)),\n            err => callback(err || null, this)\n          );\n\n        });\n\n      }\n    );\n\n  }\n\n  /**\n  * save all models (outside of beforeSave / afterSave)\n  * @param {function} callback Called with error, if applicable\n  * @private\n  */\n  __saveAll__(callback) {\n\n    let firstErrorModel = this.filter(m => m.hasErrors()).shift();\n\n    if (firstErrorModel) {\n      return callback.call(this, firstErrorModel.errorObject());\n    }\n\n    async.series(\n      this.map(m => m.__verify__.bind(m)),\n      (err) => {\n\n        if (err) {\n          return callback.call(this, err);\n        }\n\n        let db = this.Model.prototype.db;\n\n        db.transaction(\n          this.map(m => {\n            let query = m.__generateSaveQuery__();\n            return [query.sql, query.params];\n          }),\n          (err, result) => {\n\n            if (err) {\n              return callback.call(this, new Error(err.message));\n            }\n\n            this.forEach((m, i) => {\n              m.__load__(result[i].rows[0], true);\n            });\n\n            callback.call(this, null);\n\n          }\n        );\n\n      }\n    );\n\n  }\n\n}\n\nmodule.exports = ModelArray;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/required/db/transaction.js":"'use strict';\n\nconst async = require('async');\n\nconst TXN_STATUS = {\n  READY: 0,\n  COMPLETE: 1\n};\n\n/**\n* The database transaction object (ORM)\n* @class\n*/\nclass Transaction {\n\n  constructor(adapter, client, complete) {\n\n    this.adapter = adapter;\n    this._client = client;\n    this._complete = complete;\n    this._status = TXN_STATUS.READY;\n\n  }\n\n  __check__() {\n    if (this._status === TXN_STATUS.COMPLETE) {\n      throw new Error('Can not perform after transaction has completed');\n    }\n  }\n\n  complete() {\n    let complete = this._complete;\n    this._status = TXN_STATUS.COMPLETE;\n    complete();\n  }\n\n  query(sql, params, callback) {\n\n    this.__check__();\n    this.adapter.queryClient(this._client, sql, params, callback);\n\n  }\n\n  rollback(callback) {\n\n    this.__check__();\n    this.adapter.rollbackClient(this._client, err => {\n      this.complete();\n      callback(err);\n    });\n\n  }\n\n  commit(callback) {\n\n    this.__check__();\n    this.adapter.commitClient(this._client, err => {\n      this.complete();\n      callback(err);\n    });\n\n  }\n\n}\n\nmodule.exports = Transaction;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/required/utilities.js":"module.exports = require('fxn').utilities;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/required/relationship_graph.js":"'use strict';\n\nconst inflect = require('i')();\nlet __id__ = 0;\n\nclass RelationshipPath {\n\n  constructor(path) {\n    this.path = path;\n  }\n\n  toString() {\n    return this.path.join(' <-> ');\n  }\n\n  joinName(reverse) {\n\n    let path = [].slice.call(this.path);\n\n    if (reverse) {\n      path = path.reverse();\n    }\n\n    let names = [];\n\n    while (path.length > 1) {\n      let node = path.pop();\n      let edge = path.pop();\n      names.push(edge.hasChild(node) ? edge.options.name : edge.options.as);\n    }\n\n    return names.join('__');\n\n  }\n\n  add(node, edge) {\n    return new this.constructor([node, edge].concat(this.path));\n  }\n\n  getModel() {\n    return this.path[0].Model;\n  }\n\n  multiple() {\n    for (let i = 1; i < this.path.length; i += 2) {\n      let edge = this.path[i];\n      let node = this.path[i - 1];\n      if (edge.hasChild(node) && edge.options.multiple) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  immediateMultiple() {\n    let node = this.path[0];\n    let edge = this.path[1];\n    if (edge.hasChild(node) && edge.options.multiple) {\n      return true;\n    }\n    return false;\n  }\n\n  joins(alias, firstTable) {\n\n    let node;\n    let i = 0;\n    return this.path.slice().reverse().reduce((joins, item) => {\n\n      if (item instanceof RelationshipNode) {\n        node = item;\n        return joins;\n      }\n\n      let edge = item;\n\n      let join = {\n        joinTable: edge.opposite(node).Model.table(),\n        prevTable: joins[joins.length - 1] ? joins[joins.length - 1].joinAlias : (firstTable || null),\n      };\n\n      if (edge.hasChild(node)) {\n        join.prevColumn = edge.options.via;\n        join.joinColumn = edge.options.using;\n        join.joinAlias = edge.options.name;\n      } else {\n        join.prevColumn = edge.options.using;\n        join.joinColumn = edge.options.via;\n        join.joinAlias = edge.options.as;\n      }\n\n      join.joinAlias = alias ? `${alias}${++i}` : join.joinAlias;\n\n      joins.push(join);\n\n      return joins;\n\n    }, []);\n\n  }\n\n}\n\nclass RelationshipNode {\n\n  constructor(Graph, Model) {\n    this.Graph = Graph;\n    this.Model = Model;\n    this.edges = [];\n  }\n\n  toString() {\n    return `[Node: ${this.Model.name}]`;\n  }\n\n  joinsTo(Model, options) {\n\n    if (!Model.name) {\n      // Sanity check for circular dependency resolution\n      return null;\n    }\n\n    options = options || {};\n\n    options.multiple = !!options.multiple;\n    options.as = options.as || (options.multiple ? `${inflect.pluralize(inflect.camelize(this.Model.name, false))}` : `${inflect.camelize(this.Model.name, false)}`);\n    options.name = options.name || `${inflect.camelize(Model.name, false)}`;\n    options.via = options.via || `${inflect.underscore(options.name)}_id`;\n    options.using = options.using || `id`;\n\n    let parentNode = this.Graph.of(Model);\n    let edge = this.edges.filter(e => e.parent === parentNode && e.options.name === options.name).pop();\n\n    if (!edge) {\n      edge = new RelationshipEdge(parentNode, this, options);\n    }\n\n    return edge;\n\n  }\n\n  childEdges() {\n    return this.edges.filter(edge => edge.parent === this);\n  }\n\n  cascade() {\n\n    let queue = this.childEdges();\n    let paths = queue.map(e => new RelationshipPath([e.child, e, e.parent]));\n\n    let i = 0;\n    while (queue.length) {\n\n      let edge = queue.shift();\n      let curPath = paths[i++];\n\n      let nextEdges = edge.child.childEdges();\n      queue = queue.concat(nextEdges);\n\n      paths = paths.concat(nextEdges.map(e => curPath.add(e.child, e)));\n\n    }\n\n    return paths;\n\n  }\n\n  findExplicit(pathname) {\n\n    let names = pathname.split('__');\n    let node = this;\n    let path = new RelationshipPath([node]);\n\n\n    while (names.length) {\n\n      let name = names.shift();\n\n      let edges = node.edges.filter(edge => {\n        return (edge.hasChild(node) && edge.options.name === name) || edge.options.as === name;\n      });\n\n      if (edges.length === 0) {\n        return null;\n      }\n\n      let edge = edges.pop();\n      let nextNode = edge.opposite(node);\n\n      path = path.add(nextNode, edge);\n      node = nextNode;\n\n    }\n\n    return path;\n\n  }\n\n  find(name) {\n\n    let queue = this.edges\n      .slice()\n      .map(edge => {\n        return {edge: edge, path: new RelationshipPath([this])}\n      });\n\n    let traversed = {};\n\n    while (queue.length) {\n\n      let item = queue[0];\n      let curEdge = item.edge;\n      let path = item.path;\n      let node;\n\n      traversed[curEdge.id] = true;\n\n      let curNode = path.path[0];\n      node = curEdge.opposite(curNode);\n\n      if ((curEdge.hasChild(curNode) && curEdge.options.name === name) || curEdge.options.as === name) {\n        return path.add(node, curEdge);\n      }\n\n      queue = queue.slice(1).concat(\n        node.edges\n          .filter(edge => !traversed[edge.id])\n          .map(edge => {\n            return {\n              edge: edge,\n              path: path.add(node, curEdge)\n            };\n          })\n      );\n\n    }\n\n    return null;\n\n  }\n\n}\n\nclass RelationshipEdge {\n\n  constructor(parent, child, options) {\n\n    this.id = ++__id__;\n    this.parent = parent;\n    this.child = child;\n    this.options = options;\n\n    parent.edges.push(this);\n    child.edges.push(this);\n\n  }\n\n  toString() {\n    return `[Edge: ${this.parent.Model.name}, ${this.child.Model.name}]`;\n  }\n\n  hasChild(child) {\n    return this.child === child;\n  }\n\n  hasParent(parent) {\n    return this.parent === parent;\n  }\n\n  opposite(node) {\n    let opposite = this.child === node ? this.parent : (this.parent === node ? this.child : null);\n    return opposite;\n  }\n\n}\n\nclass RelationshipGraph {\n\n  constructor() {\n    this.nodes = [];\n    this.edges = [];\n  }\n\n  of(Model) {\n\n    let node = this.nodes.filter(n => n.Model === Model).pop();\n    if (!node) {\n      node = new RelationshipNode(this, Model);\n      this.nodes.push(node);\n    }\n\n    return node;\n\n  }\n\n}\n\nmodule.exports = RelationshipGraph;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/required/application.js":"'use strict';\n\nconst fxn = require('fxn');\nconst API = require('./api.js');\n\nclass Application extends fxn.Application {\n\n  constructor() {\n\n    super('Nodal');\n\n  }\n\n  /**\n  * HTTP Error\n  */\n  error(req, res, start, status, message, err) {\n\n    status = status || 500;\n    message = message || 'Internal Server Error';\n\n    let headers = {'Content-Type': 'application/json'};\n\n    err && console.log(err.stack);\n\n    this.send(\n      req,\n      res,\n      start,\n      status,\n      headers,\n      JSON.stringify(\n        API.error(\n          message,\n          (process.env.NODE_ENV !== 'production' && err) ?\n            err.stack.split('\\n') : null\n        ),\n        null,\n        2\n      ),\n      message\n    );\n\n  }\n\n}\n\nmodule.exports = Application;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/required/controller.js":"'use strict';\n\nconst fxn = require('fxn');\nconst API = require('./api.js');\n\nclass Controller extends fxn.Controller {\n\n  /**\n  * Set HTTP status code for this response. If OPTIONS mode, default to 200.\n  * @param {Number} code\n  */\n  status(value) {\n    super.status(this._method === 'OPTIONS' ? 200 : value);\n    return true;\n  }\n\n  /**\n  * Using API formatting, send an http.ServerResponse indicating there was a Bad Request (400)\n  * @param {string} msg Error message to send\n  * @param {Object} details Any additional details for the error (must be serializable)\n  * @return {boolean}\n  */\n  badRequest(msg, details) {\n    this.status(400);\n    this.render(API.error(msg || 'Bad Request', details));\n    return true;\n  }\n\n  /**\n  * Using API formatting, send an http.ServerResponse indicating there was an Unauthorized request (401)\n  * @param {string} msg Error message to send\n  * @param {Object} details Any additional details for the error (must be serializable)\n  * @return {boolean}\n  */\n  unauthorized(msg, details) {\n    this.status(401);\n    this.render(API.error(msg || 'Unauthorized', details));\n    return true;\n  }\n\n  /**\n  * Using API formatting, send an http.ServerResponse indicating the requested resource was Not Found (404)\n  * @param {string} msg Error message to send\n  * @param {Object} details Any additional details for the error (must be serializable)\n  * @return {boolean}\n  */\n  notFound(msg, details) {\n    this.status(404);\n    this.render(API.error(msg || 'Not Found', details));\n    return true;\n  }\n\n  /**\n  * Endpoint not implemented\n  * @param {string} msg Error message to send\n  * @param {Object} details Any additional details for the error (must be serializable)\n  * @return {boolean}\n  */\n  notImplemented(msg, details) {\n    this.status(501);\n    this.render(API.error(msg  || 'Not Implemented', details));\n    return true;\n  }\n\n  /**\n  * Using API formatting, send an http.ServerResponse indicating there were Too Many Requests (429) (i.e. the client is being rate limited)\n  * @param {string} msg Error message to send\n  * @param {Object} details Any additional details for the error (must be serializable)\n  * @return {boolean}\n  */\n  tooManyRequests(msg, details) {\n    this.status(429);\n    this.render(API.error(msg || 'Too Many Requests', details));\n    return true;\n  }\n\n  /**\n  * Using API formatting, send a http.ServerResponse error with a specific HTTP response status code\n  * @param {Number} code HTTP response status code\n  * @param {string} msg Response message to send\n  * @param {Object} details Any additional details for the error (must be serializable)\n  * @return {boolean}\n  */\n  statusError(code, msg, details) {\n    this.status(code);\n    this.render(API.error(msg || `${code} Status Code`, details));\n    return true;\n  }\n\n  /**\n  * Using API formatting, send an http.ServerResponse indicating there was an Internal Server Error (500)\n  * @param {string} msg Error message to send\n  * @param {Object} details Any additional details for the error (must be serializable)\n  * @return {boolean}\n  */\n  error(msg, details) {\n    this.status(500);\n    this.render(API.error(msg || 'Internal Server Error', details));\n    return true;\n  }\n\n  /**\n  * Using API formatting, generate an error or respond with model / object data.\n  * @param {Error|Object|Array|Nodal.Model|Nodal.ModelArray} data Object to be formatted for API response\n  * @param {optional Array} The interface to use for the data being returned, if not an error.\n  * @return {boolean}\n  */\n  respond(data, arrInterface) {\n\n    if (data instanceof Error) {\n\n      if (data.notFound) {\n        return this.notFound(data.message, data.details);\n      }\n\n      return this.badRequest(data.message, data.details);\n\n    }\n\n    this.render(API.format(data, arrInterface));\n    return true;\n\n  }\n\n}\n\nmodule.exports = Controller;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/cli.js":"'use strict';\n\nconst CommandLineInterface = require('cmnd').CommandLineInterface;\nconst CLI = new CommandLineInterface();\n\nCLI.load(__dirname, './commands');\n\nmodule.exports = CLI;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/db/bootstrap.js":"'use strict';\n\nconst Command = require('cmnd').Command;\n\nclass DBBootstrapCommand extends Command {\n\n  constructor() {\n\n    super('db', 'bootstrap');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Runs db:drop, db:create, db:prepare, db:migrate, db:seed',\n    };\n\n  }\n\n  run(params, callback) {\n\n    const bootstrapper = require('../../../core/my/bootstrapper.js');\n    bootstrapper.bootstrap(callback);\n\n  }\n\n}\n\nmodule.exports = DBBootstrapCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/db/compose.js":"'use strict';\n\nconst Command = require('cmnd').Command;\n\nclass DBBootstrapCommand extends Command {\n\n  constructor() {\n\n    super('db', 'compose');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Runs db:prepare, db:migrate, db:seed',\n    };\n\n  }\n\n  run(params, callback) {\n\n    const bootstrapper = require('../../../core/my/bootstrapper.js');\n    bootstrapper.compose(callback);\n\n  }\n\n}\n\nmodule.exports = DBBootstrapCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/db/create.js":"\n\n'use strict';\n\nconst Command = require('cmnd').Command;\n\nclass DBCreateCommand extends Command {\n\n  constructor() {\n\n    super('db', 'create');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Create a new PostgreSQL database for the current project'\n    };\n\n  }\n\n  run(params, callback) {\n\n    if (params.vflags.env) {\n      process.env.NODE_ENV = params.vflags.env[0];\n    }\n\n    const bootstrapper = require('../../../core/my/bootstrapper.js');\n    bootstrapper.create(callback);\n\n  }\n\n}\n\nmodule.exports = DBCreateCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/db/drop.js":"'use strict';\n\nconst Command = require('cmnd').Command;\n\nclass DBDropCommand extends Command {\n\n  constructor() {\n\n    super('db', 'drop');\n\n  }\n\n  help() {\n\n    return {\n      description: 'drops the currently active database'\n    };\n\n  }\n\n  run(params, callback) {\n\n    if (params.vflags.env) {\n      process.env.NODE_ENV = params.vflags.env[0];\n    }\n\n    const bootstrapper = require('../../../core/my/bootstrapper.js');\n    bootstrapper.drop(callback);\n\n  }\n\n}\n\nmodule.exports = DBDropCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/db/migrate.js":"'use strict';\n\nconst Command = require('cmnd').Command;\n\nclass DBMigrateCommand extends Command {\n\n  constructor() {\n\n    super('db', 'migrate');\n\n  }\n\n  help() {\n\n    return {\n      description: 'An example command',\n      vflags: {\n        step: 'The number of steps to migrate (default: all)'\n      }\n    };\n\n  }\n\n  run(params, callback) {\n\n    const bootstrapper = require('../../../core/my/bootstrapper.js');\n    bootstrapper.migrate(params.vflags.step, callback);\n\n  }\n\n}\n\nmodule.exports = DBMigrateCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/db/prepare.js":"'use strict';\n\nconst Command = require('cmnd').Command;\n\nclass DBPrepareCommand extends Command {\n\n  constructor() {\n\n    super('db', 'prepare');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Prepares your database for migrations (resets all data)'\n    };\n\n  }\n\n  run(params, callback) {\n\n    const bootstrapper = require('../../../core/my/bootstrapper.js');\n    bootstrapper.prepare(callback);\n\n  }\n\n}\n\nmodule.exports = DBPrepareCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/db/rollback.js":"'use strict';\n\nconst Command = require('cmnd').Command;\n\nclass DBRollbackCommand extends Command {\n\n  constructor() {\n\n    super('db', 'rollback');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Rollback completed migrations',\n      vflags: {\n        step: 'Number of steps to rollback (default: 1)'\n      }\n    };\n\n  }\n\n  run(params, callback) {\n\n    const bootstrapper = require('../../../core/my/bootstrapper.js');\n    bootstrapper.rollback(params.vflags.step, callback);\n\n  }\n\n}\n\nmodule.exports = DBRollbackCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/db/seed.js":"'use strict';\n\nconst Command = require('cmnd').Command;\n\nclass DBSeedCommand extends Command {\n\n  constructor() {\n\n    super('db', 'seed');\n\n  }\n\n  help() {\n\n    return {\n      description: `Seeds the database with data in './config/seed.json'`\n    };\n\n  }\n\n  run(params, callback) {\n\n    const bootstrapper = require('../../../core/my/bootstrapper.js');\n    bootstrapper.seed(callback);\n\n  }\n\n}\n\nmodule.exports =  DBSeedCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/db/version.js":"'use strict';\n\nconst Command = require('cmnd').Command;\n\nclass DBVersionCommand extends Command {\n\n  constructor() {\n\n    super('db', 'version');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Gets the current schema version from the database'\n    };\n\n  }\n\n  run(params, callback) {\n\n    const bootstrapper = require('../../../core/my/bootstrapper.js');\n    bootstrapper.version(callback);\n\n  }\n\n}\n\nmodule.exports = DBVersionCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/g/controller.js":"'use strict';\n\nconst Command = require('cmnd').Command;\n\nconst fs = require('fs');\n\nconst colors = require('colors/safe');\nconst inflect = require('i')();\n\nconst dot = require('dot');\nlet templateSettings = Object.keys(dot.templateSettings).reduce((o, k) => {\n  o[k] = dot.templateSettings[k];\n  return o;\n}, {})\ntemplateSettings.strip = false;\ntemplateSettings.varname = 'data';\n\nlet controllerDir = './app/controllers';\n\nfunction generateController(controllerName, forModel) {\n\n  let controller = {\n    name: controllerName,\n    for: forModel\n  };\n\n  var fn = dot.template(\n    fs.readFileSync(__dirname + '/../../templates/controller.jst').toString(),\n    templateSettings\n  );\n\n  return fn(controller);\n\n}\n\nfunction generateRoute(controllerName, controllerPath, controllerRoute) {\n\n  let importStatement = [\n    'const ',\n      controllerName,\n    ' = ',\n    'Nodal.require(\\'app/controllers/',\n      controllerPath.join('/'),\n    '\\');'\n  ].join('')\n\n  let routeStatement = [\n    `router.route('/`,\n    controllerPath.slice(0, -1).concat([controllerRoute]).join('/'),\n    `/\\{id\\}').use(`,\n    controllerName,\n    ');'\n  ].join('');\n\n  let routes = fs.readFileSync('./app/router.js').toString();\n\n  routes = routes.split('\\n');\n\n  let importIndex = routes.map(function(v, i) {\n    return {\n      spaces: v.indexOf('/* generator: end imports */'),\n      index: i\n    }\n  }).filter(function(v) {\n    return v.spaces > -1;\n  }).pop();\n\n  if (importIndex !== undefined) {\n\n    routes = routes.slice(0, importIndex.index - 1).concat(\n      [\n        Array(importIndex.spaces + 1).join(' ') + importStatement,\n      ],\n      routes.slice(importIndex.index - 1)\n    );\n\n  }\n\n  let routeIndex = routes.map(function(v, i) {\n    return {\n      spaces: v.indexOf('/* generator: end routes */'),\n      index: i\n    }\n  }).filter(function(v) {\n    return v.spaces > -1;\n  }).pop();\n\n  if (routeIndex !== undefined) {\n\n    routes = routes.slice(0, routeIndex.index - 1).concat(\n      [\n        Array(routeIndex.spaces + 1).join(' ') + routeStatement,\n      ],\n      routes.slice(routeIndex.index - 1)\n    );\n\n  }\n\n  fs.writeFileSync('./app/router.js', routes.join('\\n'));\n\n  console.log(colors.green.bold('Modify: ') + './app/router.js');\n\n}\n\nclass GenerateControllerCommand extends Command {\n\n  constructor() {\n\n    super('g', 'controller');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Creates a new controller, and adds a default route',\n      args: ['controller name'],\n      vflags: {for: 'The model the controller is for'}\n    };\n\n  }\n\n  run(params, callback) {\n\n    if (!params.args.length && !params.vflags.for) {\n      return callback(new Error('No controller path specified.'));\n    }\n\n    let controllerPath = params.args[0] ? params.args[0].split('/') : [];\n    let cd = controllerDir;\n\n    let forModel = null;\n\n    if (Object.keys(params.vflags).filter(key => key.substr(0, 4) === 'for:').length) {\n      return callback(new Error('Syntax `--for:ModelName` removed. Use `--for ModelName` instead.'));\n    }\n\n    if (params.vflags.for) {\n\n      forModel = {\n        name: inflect.classify(params.vflags.for[0]),\n        path: 'app/models/' + inflect.underscore(inflect.classify(params.vflags.for[0])) + '.js'\n      };\n\n      controllerPath.push(inflect.tableize(forModel.name));\n\n    }\n\n    let controllerRoute = inflect.underscore(controllerPath.pop());\n\n    let controllerName = inflect.classify(controllerRoute + '_controller');\n\n    controllerPath = controllerPath.map(function(v) {\n      return inflect.underscore(v);\n    });\n\n    let fullControllerName = inflect.classify(controllerPath.concat([controllerName]).join('_'));\n    let fullControllerPath = controllerPath.concat([inflect.underscore(controllerName) + '.js']);\n\n    let createPath = [controllerDir].concat(fullControllerPath).join('/');\n\n    if (fs.existsSync(createPath)) {\n      return callback(new Error('Controller already exists'));\n    }\n\n    while (controllerPath.length && (cd += '/' + controllerPath.shift()) && !fs.existsSync(cd)) {\n      fs.mkdirSync(cd);\n      cd += '/' + controllerPath.shift();\n    }\n\n    fs.writeFileSync(createPath, generateController(fullControllerName, forModel));\n\n    console.log(colors.green.bold('Create: ') + createPath);\n\n    generateRoute(fullControllerName, fullControllerPath, controllerRoute);\n\n    callback(null);\n\n  }\n\n}\n\nmodule.exports = GenerateControllerCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/g/middleware.js":"'use strict';\n\nconst Command = require('cmnd').Command;\n\nconst fs = require('fs');\n\nconst colors = require('colors/safe');\nconst inflect = require('i')();\n\nconst dot = require('dot');\n\nlet templateSettings = Object.keys(dot.templateSettings).reduce((o, k) => {\n  o[k] = dot.templateSettings[k];\n  return o;\n}, {})\ntemplateSettings.strip = false;\ntemplateSettings.varname = 'data';\n\nlet middlewareDir = './middleware';\n\nfunction generateMiddleware(middlewareName) {\n\n  let middleware = {\n    name: middlewareName,\n  };\n\n  var fn = dot.template(\n    fs.readFileSync(__dirname + '/../../templates/middleware.jst').toString(),\n    templateSettings\n  );\n\n  return fn(middleware);\n\n}\n\nclass GenerateMiddlewareCommand extends Command {\n\n  constructor() {\n\n    super('g', 'middleware');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Generate new Middleware (runs pre-controller)',\n      args: ['middleware name']\n    };\n\n  }\n\n  run(params, callback) {\n\n    if (!params.args.length) {\n      return callback(new Error('No middleware path specified.'));\n    }\n\n    let middlewarePath = params.args[0].split('/');\n    let cd = middlewareDir;\n\n    let middlewareName = inflect.classify(middlewarePath.pop());\n\n    middlewarePath = middlewarePath.map(function(v) {\n      return inflect.underscore(v);\n    });\n\n    let createPath = [middlewareDir].concat(middlewarePath).join('/') + '/' + inflect.underscore(middlewareName) + '_middleware.js';\n\n    if (fs.existsSync(createPath)) {\n      return callback(new Error('middleware already exists'));\n    }\n\n    while (middlewarePath.length && (cd += '/' + middlewarePath.shift()) && !fs.existsSync(cd)) {\n      fs.mkdirSync(cd);\n      cd += '/' + middlewarePath.shift();\n    }\n\n    fs.writeFileSync(createPath, generateMiddleware(middlewareName));\n\n    console.log(colors.green.bold('Create: ') + createPath);\n\n    callback(null);\n\n  }\n\n}\n\nmodule.exports = GenerateMiddlewareCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/g/migration.js":"'use strict';\n\nconst Command = require('cmnd').Command;\n\nconst Database = require('../../../core/module.js').Database;\n\nconst fs = require('fs');\nconst inflect = require('i')();\nconst colors = require('colors/safe');\nconst dot = require('dot');\n\nlet templateSettings = Object.keys(dot.templateSettings).reduce((o, k) => {\n  o[k] = dot.templateSettings[k];\n  return o;\n}, {})\ntemplateSettings.strip = false;\ntemplateSettings.varname = 'data';\n\nlet migrationDir = './db/migrations';\n\nfunction composeMigration(up, down) {\n\n  up =  up || [];\n  down = down || [];\n\n  return function(migrationName, id) {\n\n    let migration = {\n      up: up,\n      down: down,\n      name: migrationName,\n      id: parseInt(id) || 0\n    };\n\n    return dot.template(\n      fs.readFileSync(__dirname + '/../../templates/migration.jst').toString(),\n      templateSettings\n    )(migration);\n\n  };\n\n}\n\nfunction generateId(date) {\n\n  function padZero(n, l) {\n\n    n = n.toString();\n    return Array(1 + Math.max(0, l - n.length)).join('0') + n;\n\n  }\n\n  return parseInt([\n    [date.getUTCFullYear(), 4],\n    [date.getUTCMonth() + 1, 2],\n    [date.getUTCDate(), 2],\n    [date.getUTCHours(), 2],\n    [date.getUTCMinutes(), 2],\n    [date.getUTCSeconds(), 2],\n    [(date.getUTCMilliseconds() / 10) | 0, 2]\n  ].map(function(v) {\n    return padZero.apply(null, v);\n  }).join(''));\n\n}\n\nfunction generateMigration(migrationName, up, down, id) {\n\n  id = id || generateId(new Date());\n  let migrationFileName = id + '__' + inflect.underscore(migrationName) + '.js';\n\n  !fs.existsSync(migrationDir) && fs.mkdirSync(migrationDir);\n\n  let migrationPath = migrationDir + '/' + migrationFileName;\n\n  if (fs.existsSync(migrationPath)) {\n    throw new Error('Migration already exists');\n  }\n\n  fs.writeFileSync(migrationPath, composeMigration(up, down)(migrationName, id));\n\n  console.log(colors.green.bold('Create: ') + migrationPath);\n\n}\n\nfunction convertArgListToPropertyList(argList) {\n\n  // Instantiate Database so we can get access to the Adapater types\n  let db = new Database();\n  db.connect(require(`${process.cwd()}/config/db.json`)[process.env.NODE_ENV || 'development']);\n\n  return argList.slice(1).map(function(v) {\n\n    v = v.split(':');\n\n    if (Object.keys(db.adapter.types).indexOf(v[1].toLowerCase()) == -1) {\n      throw new Error(`Un-supported column type ${colors.yellow.bold(v[1])} for field ${colors.yellow.bold(v[0])}`);\n    }\n\n    let obj = {name: inflect.underscore(v[0]), type: v[1].toLowerCase()};\n    let rest = v.slice(2);\n    let properties = {};\n\n    ['array', 'unique'].forEach(v => {\n      if (rest.indexOf(v) !== -1) {\n        properties[v] = true;\n      }\n    });\n\n    Object.keys(properties).length && (obj.properties = properties);\n\n    return obj;\n\n  });\n\n}\n\nfunction generateModelSchemaObject(modelName, propertyList) {\n\n  return {\n    table: inflect.tableize(modelName),\n    columns: propertyList\n  };\n\n}\n\nclass GenerateMigrationCommand extends Command {\n\n  constructor() {\n\n    super('g', 'migration');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Generate a new, empty migration. Optionally to add / remove columns.',\n      args: ['migration name'],\n      vflags: {\n        add: '[table] [field_1:type_1] [...] [field_n:type_n]'\n      }\n    };\n\n  }\n\n  run(params, callback) {\n\n    let migrationName = inflect.camelize(params.args[0]);\n\n    if (!migrationName) {\n      throw new Error('Migration name not specified');\n    }\n\n    let up = [];\n    let down = [];\n\n    if (params.vflags.for) {\n\n      let forArgs = params.vflags.for;\n      let schemaObject = generateModelSchemaObject(forArgs[0], convertArgListToPropertyList(forArgs));\n\n      up.push('this.createTable(\\\"' + schemaObject.table + '\\\", ' + JSON.stringify(schemaObject.columns) + ')');\n      down.push('this.dropTable(\\\"' + schemaObject.table + '\\\")');\n\n    }\n\n    if (params.vflags.add) {\n\n      let table = params.vflags.add[0];\n\n      params.vflags.add.slice(1).forEach(field => {\n        field = field.split(':');\n        up.push(`this.addColumn('${table}', '${field[0]}', '${field[1]}')`);\n        down.unshift(`this.dropColumn('${table}', '${field[0]}')`);\n      });\n\n    }\n\n    generateMigration(migrationName, up, down);\n\n    callback(null);\n\n  }\n\n}\n\nmodule.exports = GenerateMigrationCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/g/model.js":"'use strict';\n\nconst Command = require('cmnd').Command;\nconst GenerateMigrationCommand = require('./migration.js');\nconst generateMigration = new GenerateMigrationCommand();\n\nconst fs = require('fs');\nconst Database = require('../../../core/module.js').Database;\n\nconst colors = require('colors/safe');\nconst inflect = require('i')();\n\nconst dot = require('dot');\nlet templateSettings = Object.keys(dot.templateSettings).reduce((o, k) => {\n  o[k] = dot.templateSettings[k];\n  return o;\n}, {})\ntemplateSettings.strip = false;\ntemplateSettings.varname = 'data';\n\nlet modelDir = './app/models';\n\nfunction generateModelDefinition(modelName, columns) {\n\n  let model = {\n    name: modelName,\n    columns: columns\n  };\n\n  return dot.template(\n    fs.readFileSync(__dirname + '/../../templates/model.jst').toString(),\n    templateSettings\n  )(model);\n\n}\n\nfunction generateUserDefinition() {\n  return dot.template(\n    fs.readFileSync(__dirname + '/../../templates/models/user.jst').toString(),\n    templateSettings\n  )();\n};\n\nfunction generateAccessTokenDefinition() {\n  return dot.template(\n    fs.readFileSync(__dirname + '/../../templates/models/access_token.jst').toString(),\n    templateSettings\n  )();\n};\n\nfunction convertArgListToPropertyList(argList) {\n\n  // Instantiate Database so we can get access to the Adapater types\n  let db = new Database();\n  db.connect(require(`${process.cwd()}/config/db.json`)[process.env.NODE_ENV || 'development']);\n\n  return argList.slice(1).map(function(v) {\n\n    v = v.split(':');\n\n    if (Object.keys(db.adapter.types).indexOf(v[1].toLowerCase()) == -1) {\n      throw new Error(`Un-supported column type ${colors.yellow.bold(v[1])} for field ${colors.yellow.bold(v[0])}`);\n    }\n\n    let obj = {name: inflect.underscore(v[0]), type: v[1].toLowerCase()};\n    let rest = v.slice(2);\n    let properties = {};\n\n    ['array', 'unique'].forEach(v => {\n      if (rest.indexOf(v) !== -1) {\n        properties[v] = true;\n      }\n    });\n\n    Object.keys(properties).length && (obj.properties = properties);\n\n    return obj;\n\n  });\n\n}\n\nfunction generateModelSchemaObject(modelName, propertyList) {\n\n  let tableName = inflect.tableize(modelName);\n  if (propertyList.filter(c => c.name === tableName).length) {\n    throw new Error(`Can not create a table with an identical field name. (${tableName}.${tableName})`);\n  }\n\n  return {\n    table: inflect.tableize(modelName),\n    columns: propertyList\n  };\n\n}\n\nclass GenerateModelCommand extends Command {\n\n  constructor() {\n\n    super('g', 'model');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Generate a new model and associated migration',\n      args: ['ModelName', 'field_1:type_1', '...', 'field_n:type_n'],\n      vflags: {\n        user: 'Use a prebuilt User model',\n        access_token: 'Use a prebuilt AccessToken model'\n      }\n    };\n\n  }\n\n  run(params, callback) {\n\n    if (params.vflags.hasOwnProperty('user')) {\n      params.args = [\n        'User',\n        'email:string:unique',\n        'password:string',\n        'username:string'\n      ];\n    } else if (params.vflags.hasOwnProperty('access_token')) {\n      params.args = [\n        'AccessToken',\n        'user_id:int',\n        'access_token:string',\n        'token_type:string',\n        'expires_at:datetime',\n        'ip_address:string'\n      ];\n    }\n\n    if (!params.args.length) {\n      return callback(new Error('No model name specified.'));\n    }\n\n    let modelName = inflect.classify(params.args[0]);\n    let schemaObject;\n\n    try {\n      schemaObject = generateModelSchemaObject(modelName, convertArgListToPropertyList(params.args));\n    } catch(e) {\n      return callback(e);\n    }\n\n    !fs.existsSync(modelDir) && fs.mkdirSync(modelDir);\n\n    let createPath = modelDir + '/' + inflect.underscore(modelName) + '.js';\n\n    if (fs.existsSync(createPath)) {\n      return callback(new Error('Model already exists'));\n    }\n\n    if (params.vflags.hasOwnProperty('user')) {\n\n      fs.writeFileSync(createPath, generateUserDefinition());\n\n    } else if (params.vflags.hasOwnProperty('access_token')) {\n\n      fs.writeFileSync(createPath, generateAccessTokenDefinition());\n\n    } else {\n\n      fs.writeFileSync(createPath, generateModelDefinition(modelName));\n    }\n\n    console.log(colors.green.bold('Create: ') + createPath);\n\n    generateMigration.run({\n      args: [`create_${schemaObject.table}`],\n      flags: [],\n      vflags: {for: params.args}\n    }, (err, result) => {\n\n      if (err) {\n        return callback(err);\n      }\n\n      if (params.vflags.hasOwnProperty('user')) {\n\n        console.log('Installing additional packages in this directory...');\n        console.log('');\n\n        let spawn = require('cross-spawn-async');\n        let child = spawn('npm',  ['install', 'bcryptjs', '--save'], {cwd: process.cwd(), stdio: 'inherit'});\n\n        child.on('exit', function() {\n\n          child && child.kill();\n          callback(null);\n\n        });\n\n        return;\n\n      }\n\n      callback(null);\n\n    });\n\n  }\n\n}\n\nmodule.exports = GenerateModelCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/g/renderware.js":"'use strict';\n\nconst Command = require('cmnd').Command;\n\nconst fs = require('fs');\n\nconst colors = require('colors/safe');\nconst inflect = require('i')();\n\nconst dot = require('dot');\n\nlet templateSettings = Object.keys(dot.templateSettings).reduce((o, k) => {\n  o[k] = dot.templateSettings[k];\n  return o;\n}, {})\ntemplateSettings.strip = false;\ntemplateSettings.varname = 'data';\n\nlet renderwareDir = './renderware';\n\nfunction generateRenderware(renderwareName) {\n\n  let renderware = {\n    name: renderwareName,\n  };\n\n  var fn = dot.template(\n    fs.readFileSync(__dirname + '/../../templates/renderware.jst').toString(),\n    templateSettings\n  );\n\n  return fn(renderware);\n\n}\n\nclass GenerateRenderwareCommand extends Command {\n\n  constructor() {\n\n    super('g', 'renderware');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Generate new Renderware (runs post-controller)',\n      args: ['renderware name']\n    };\n\n  }\n\n  run(params, callback) {\n\n    if (!params.args.length) {\n      return callback(new Error('No renderware path specified.'));\n    }\n\n    let renderwarePath = params.args[0].split('/');\n    let cd = renderwareDir;\n\n    let renderwareName = inflect.classify(renderwarePath.pop());\n\n    renderwarePath = renderwarePath.map(function(v) {\n      return inflect.underscore(v);\n    });\n\n    let createPath = [renderwareDir].concat(renderwarePath).join('/') + '/' + inflect.underscore(renderwareName) + '_renderware.js';\n\n    if (fs.existsSync(createPath)) {\n      return callback(new Error('renderware already exists'));\n    }\n\n    while (renderwarePath.length && (cd += '/' + renderwarePath.shift()) && !fs.existsSync(cd)) {\n      fs.mkdirSync(cd);\n      cd += '/' + renderwarePath.shift();\n    }\n\n    fs.writeFileSync(createPath, generateRenderware(renderwareName));\n\n    console.log(colors.green.bold('Create: ') + createPath);\n\n    callback(null);\n\n  }\n\n}\n\nmodule.exports = GenerateRenderwareCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/g/task.js":"'use strict';\n\nconst Command = require('cmnd').Command;\n\nconst fs = require('fs');\n\nconst colors = require('colors/safe');\nconst inflect = require('i')();\n\nconst dot = require('dot');\n\nlet templateSettings = Object.keys(dot.templateSettings).reduce((o, k) => {\n  o[k] = dot.templateSettings[k];\n  return o;\n}, {})\ntemplateSettings.strip = false;\ntemplateSettings.varname = 'data';\n\nlet taskDir = './tasks';\n\nfunction generateTask(taskName) {\n\n  let task = {\n    name: taskName,\n  };\n\n  var fn = dot.template(\n    fs.readFileSync(__dirname + '/../../templates/task.jst').toString(),\n    templateSettings\n  );\n\n  return fn(task);\n\n}\n\nclass GenerateTaskCommand extends Command {\n\n  constructor() {\n\n    super('g', 'task');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Generates a new task',\n      args: ['task name']\n    };\n\n  }\n\n  run(params, callback) {\n\n    if (!params.args.length) {\n      return callback(new Error('No task path specified.'));\n    }\n\n    let taskPath = params.args[0].split('/');\n    let cd = taskPath\n\n    let taskName = inflect.classify(taskPath.pop());\n\n    taskPath = taskPath.map(function(v) {\n      return inflect.underscore(v);\n    });\n\n    let createPath = [taskDir].concat(taskPath).join('/') + '/' + inflect.underscore(taskName) + '.js';\n\n    if (fs.existsSync(createPath)) {\n      return callback(new Error('task already exists'));\n    }\n\n    while (taskPath.length && (cd += '/' + taskPath.shift()) && !fs.existsSync(cd)) {\n      fs.mkdirSync(cd);\n      cd += '/' + taskPath.shift();\n    }\n\n    fs.writeFileSync(createPath, generateTask(taskName));\n\n    console.log(colors.green.bold('Create: ') + createPath);\n\n    callback(null);\n\n  }\n\n}\n\nmodule.exports = GenerateTaskCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/g/test.js":"'use strict';\n\nconst Command = require('cmnd').Command;\n\nconst fs = require('fs');\nconst colors = require('colors/safe');\nconst inflect = require('i')();\nconst dot = require('dot');\n\nlet templateSettings = Object.keys(dot.templateSettings).reduce((o, k) => {\n  o[k] = dot.templateSettings[k];\n  return o;\n}, {})\ntemplateSettings.strip = false;\ntemplateSettings.varname = 'data';\n\nlet testDir = './test/tests';\n\nfunction generateTest(testName) {\n\n  let test = {\n    name: testName,\n  };\n\n  var fn = dot.template(\n    fs.readFileSync(__dirname + '/../../templates/test.jst').toString(),\n    templateSettings\n  );\n\n  return fn(test);\n\n}\n\nclass GenerateTestCommand extends Command {\n\n  constructor() {\n\n    super('g', 'test');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Generates a new test',\n      args: ['test']\n    };\n\n  }\n\n  run(params, callback) {\n\n    if (!params.args.length) {\n      return callback(new Error('No test path specified.'));\n    }\n\n    let testPath = params.args[0].split('/');\n    let cd = testPath;\n\n    let testName = inflect.classify(testPath.pop()) + 'Test';\n\n    testPath = testPath.map(function(v) {\n      return inflect.underscore(v);\n    });\n\n    let createPath = [testDir].concat(testPath).join('/') + '/' + inflect.underscore(testName) + '.js';\n\n    if (fs.existsSync(createPath)) {\n      callback(new Error('test already exists'));\n    }\n\n    while (testPath.length && (cd += '/' + testPath.shift()) && !fs.existsSync(cd)) {\n      fs.mkdirSync(cd);\n      cd += '/' + testPath.shift();\n    }\n\n    fs.writeFileSync(createPath, generateTest(testName));\n\n    console.log(colors.green.bold('Create: ') + createPath);\n\n    callback(null);\n\n  }\n\n}\n\nmodule.exports = GenerateTestCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/new.js":"'use strict';\n\nconst Command = require('cmnd').Command;\n\nconst fs = require('fs-extra');\nconst path = require('path');\nconst inquirer = require('inquirer');\nconst inflect = require('i')();\nconst colors = require('colors/safe');\nconst async = require('async');\nconst http = require('http');\n\nclass NewCommand extends Command {\n\n  constructor() {\n\n    super('new');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Initialize the current directory as a new Nodal project'\n    };\n\n  }\n\n  run(params, callback) {\n\n    if (fs.existsSync('./.nodal')) {\n      return callback(new Error('Nodal project already exists in this directory'));\n    }\n\n    const rootPath = path.resolve(__dirname);\n    const version = require('../../package.json').version;\n\n    console.log('');\n    console.log(`Welcome to ${colors.bold.green('Nodal! v' + version)}`);\n    console.log('');\n\n    let data = {\n      name: params.args[0] ? (params.args[0] + '').replace(/_/g, ' ') : '',\n      author: (params.vflags.author || '').replace(/_/g, ' ') || '',\n      ignoreOutput: params.vflags.hasOwnProperty('ignore-output')\n    };\n\n    let questions = [];\n\n    !data.name && questions.push({\n      name: 'project-name',\n      type: 'input',\n      default: 'my-nodal-project',\n      message: 'Name',\n    });\n\n    !data.author && questions.push({\n      name: 'author',\n      type: 'input',\n      default: 'mysterious author',\n      message: 'Author',\n    });\n\n    // Count new nodal projects being made. :)\n    let req = http.request({host: 'api.polybit.com', port: 80, path: `/v1/nodal_initializations?version=${version}`, method: 'POST'});\n    req.on('error', (() => {}));\n    req.end();\n\n    inquirer.prompt(questions, (promptResult) => {\n\n      promptResult.name = promptResult['project-name'] || data.name;\n      promptResult.author = promptResult.author || data.author;\n\n      promptResult.simpleName = promptResult.name.replace(/\\s/gi, '-');\n\n      promptResult.databaseName = inflect.underscore(promptResult.simpleName);\n\n      promptResult.version = version;\n\n      let dirname = promptResult.name.replace(/[^A-Za-z0-9-_]/gi, '-').toLowerCase();\n\n      console.log('Creating directory \"' + dirname + '\"...');\n      console.log('');\n\n      if (fs.existsSync('./' + dirname)) {\n        callback(new Error('Directory \"' + dirname + '\" already exists, try a different project name'));\n      }\n\n      fs.mkdirSync('./' + dirname);\n\n      console.log('Copying Nodal directory structure and files...');\n      console.log('');\n\n      fs.copy(rootPath + '/../../src', './' + dirname, function(err) {\n\n        if (err) return callback(err);\n\n        let dot = require('dot');\n\n        dot.templateSettings.strip = false;\n        dot.templateSettings.varname = 'data';\n\n        // Write .env\n        fs.writeFileSync('./' + dirname + '/.env', 'EXAMPLE_ENV_VAR=hello');\n\n        fs.writeFileSync('./' + dirname + '/package.json', dot.template(\n          fs.readFileSync(rootPath + '/../templates/package.json.jst').toString()\n        )(promptResult));\n\n        fs.writeFileSync('./' + dirname + '/README.md', dot.template(\n          fs.readFileSync(rootPath + '/../templates/README.md.jst').toString()\n        )(promptResult));\n\n        // read in the dbjson template, replace the development database name\n        // generate new config/db.json in the generated app\n        // NOTE: The db.json is intentionally not conditionally wrapped based\n        // on DB support since if users want to enable it later, worse case it\n        // defaults to an underscored version  <appname>_development\n        let dbjson = JSON.parse(fs.readFileSync(rootPath + '/../templates/db.json'));\n        dbjson.development.main.database = promptResult.databaseName + '_development';\n        dbjson.test.main.database = promptResult.databaseName + '_test';\n        fs.writeFileSync('./' + dirname + '/config/db.json', JSON.stringify(dbjson, null, 2));\n\n        let copyNodeModules = [\n          'cli', 'core', 'test', 'node_modules',\n          'package.json'\n        ];\n\n        async.series(\n          copyNodeModules.map(m => {\n            return (callback) => {\n\n              console.log(`Copying ${m}...`);\n              fs.copy(\n                path.join(rootPath, '..', '..', m),\n                path.join(process.cwd(), dirname, 'node_modules', 'nodal', m),\n                callback\n              );\n\n            };\n          }),\n          (err) => {\n\n            if (err) {\n              callback(err);\n            }\n\n            if (!data.ignoreOutput) {\n              console.log('');\n              console.log(colors.bold.green('All done!'));\n              console.log('');\n              console.log('Your new Nodal project, ' + colors.bold(promptResult.name) + ', is ready to go! :)');\n              console.log('');\n              console.log('Have fun ' + promptResult.author + ', and check out https://github.com/keithwhor/nodal for the most up-to-date Nodal information')\n              console.log('');\n              console.log(colors.bold('Pro tip: ') + 'You can try running your server right away with:');\n              console.log('');\n              console.log('  cd ' + dirname + ' && nodal s');\n              console.log('');\n            }\n\n            callback(null);\n\n          }\n        );\n\n      });\n\n    });\n\n  }\n\n}\n\nmodule.exports = NewCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/poly/compile.js":"'use strict';\n\nconst Command = require('cmnd').Command;\nconst async = require('async');\nconst colors = require('colors/safe');\n\nconst PolyDeployCommand = require('./deploy.js');\nconst PolyRunCommand = require('./run.js');\n\nclass PolyCompileCommand extends Command {\n\n  constructor() {\n\n    super('poly', 'compile');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Compiles your Nodal API to the cloud, runs database migrations',\n      args: ['projectName'],\n      vflags: {\n        prepare: 'Runs db:prepare after compilation (resets DB)',\n        'no-migrate': 'Do not run db:migrate after compilation'\n      }\n    };\n\n  }\n\n  run(params, callback) {\n\n    let name = params.args[0];\n\n    let commands = [\n      cb => PolyDeployCommand.prototype.run({args: [name], flags: params.flags, vflags: params.vflags}, cb)\n    ];\n\n    params.vflags.prepare && commands.push(cb => PolyRunCommand.prototype.run({args: [name, 'db:prepare'], flags: params.flags, vflags: params.vflags}, cb));\n    vflags['no-migrate'] || commands.push(cb => PolyRunCommand.prototype.run({args: [name, 'db:migrate'], flags: params.flags, vflags: params.vflags}, cb));\n\n    async.series(commands, (err, results) => {\n\n      if (err) {\n        return callback(err);\n      }\n\n      console.log('');\n      console.log(colors.bold.green('Awesome. Compilation Successful!'));\n      console.log(`Access your API online at:`)\n      console.log(colors.bold(results[0].url));\n      console.log();\n      callback();\n\n    });\n\n  }\n\n}\n\nmodule.exports = PolyCompileCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/poly/deploy.js":"'use strict';\n\nconst Command = require('cmnd').Command;\nconst APIResource = require('api-res');\nconst Credentials = require('../../credentials.js');\nconst PolyCreditsCommand = require('./credits.js');\n\nconst fs = require('fs');\nconst zlib = require('zlib');\nconst async = require('async');\nconst path = require('path');\n\nclass PolyDeployCommand extends Command {\n\n  constructor() {\n\n    super('poly', 'deploy');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Deploys current directory as a Nodal project',\n      args: ['project']\n    };\n\n  }\n\n  run(params, callback) {\n\n    if (!fs.existsSync(path.join(process.cwd(), '.nodal'))) {\n      return callback(new Error('Must run `nodal poly:deploy` or `nodal poly:compile` from a valid Nodal project.'));\n    }\n\n    let name = params.args[0];\n\n    let host = params.flags.h ? params.flags.h[0] : 'https://api.polybit.com';\n    let port = params.flags.p && params.flags.p[0];\n\n    let resource = new APIResource(host, port);\n    resource.authorize(Credentials.read('ACCESS_TOKEN'));\n\n    async.parallel([\n      (cb) => {\n\n        resource.request('v1/projects').index({name: name}, (err, response) => {\n\n          if (err) {\n            return cb(err);\n          }\n\n          if (response.data.length < 1) {\n            return cb(new Error(`Could not deploy: Project \"${name}\" does not exist.`));\n          }\n\n          let project = response.data[0];\n\n          cb(null, project);\n\n        })\n\n      }\n    ], (err, results) => {\n\n      if (err) {\n        return callback(err);\n      }\n\n      console.log('Compiling...');\n\n      let project = results[0];\n\n      let files = [\n        'app',\n        'config',\n        'db',\n        'middleware',\n        'node_modules',\n        'renderware'\n      ].reduce(this.list.bind(this), []).map(filename => {\n\n        return (cb) => {\n          return fs.readFile(filename, (err, result) => {\n            return cb(err, {filename: filename, data: result.toString('base64')});\n          });\n        };\n\n      });\n\n      async.parallel(files, (err, result) => {\n\n        let buffer = new Buffer(JSON.stringify(result));\n\n        zlib.deflate(buffer, (err, compressed) => {\n\n          if (err) {\n            console.error(`Could not deploy: ${err.message}`);\n            return callback(err);\n          }\n\n          console.log(`Package size: ${compressed.length} (${(compressed.length / (1024 * 1024)).toFixed(2)} MB)`);\n          console.log('Deploying...');\n\n          let finish = (() => {\n            let t = new Date().valueOf();\n            let length = 50;\n            let barSize = 10;\n            let emptyChar = '-';\n            let barChar = '=';\n            let i = 0;\n            let progress = setInterval(() => {\n              process.stdout.write(`\\r[${emptyChar.repeat(i % length)}${barChar.repeat(barSize)}${emptyChar.repeat(length - (i % length) - 1)}]`);\n              i++;\n            }, 50);\n            return () => {\n              clearInterval(progress);\n              process.stdout.write(`\\rDeployed in ${((new Date().valueOf() - t) / 1000) | 0} seconds!${' '.repeat(length)}\\n`);\n            };\n          })();\n\n\n          resource.request('v1/projects').update(project.id, {action: 'deploy'}, compressed, (err, response) => {\n\n            finish();\n\n            if (err) {\n              console.error(`Could not deploy: ${err.message}`);\n              return callback(err);\n            }\n\n            console.log('Deployment complete!');\n\n            PolyCreditsCommand.prototype.run({args: [], flags: params.flags, vflags: params.vflags}, () => {\n\n              return callback(null, response.data[0]);\n\n            });\n\n          });\n\n        });\n\n      });\n\n    });\n\n  }\n\n  list(files, filename) {\n\n    let path = process.cwd() + '/' + filename;\n\n    if (!fs.existsSync(path)) {\n      return;\n    }\n\n    let stat = fs.statSync(path);\n\n    if (stat.isDirectory()) {\n      return fs\n        .readdirSync(path)\n        .map(v => `${filename}/${v}`)\n        .reduce(this.list.bind(this), files);\n    }\n\n    files.push(filename);\n    return files;\n\n  }\n\n}\n\nmodule.exports = PolyDeployCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/credentials.js":"'use strict';\n\nconst path = require('path');\nconst fs = require('fs');\nconst FILENAME = '.polybit';\n\nfunction readCredentials() {\n\n  let cred = '';\n\n  try {\n    cred = fs.readFileSync(path.join(process.cwd(), '.polybit')).toString();\n  } catch (e) {\n    cred = '';\n  }\n\n  return cred\n    .split('\\n')\n    .filter(v => v)\n    .map(l => l.split('='))\n    .reduce((p, c) => { return (p[c[0]] = c[1]), p; }, {})\n\n}\n\nfunction writeCredentials(obj) {\n\n  let str = Object.keys(obj).map(k => `${k}=${obj[k]}`).join('\\n') + '\\n';\n  fs.writeFileSync(path.join(process.cwd(), '.polybit'), str);\n\n}\n\nmodule.exports = {\n\n  read: (key) => {\n\n    return readCredentials()[key];\n\n  },\n\n  write: (key, value) => {\n\n    let cred = readCredentials();\n    cred[key] = value;\n    writeCredentials(cred);\n    return true;\n\n  }\n\n};\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/poly/credits.js":"'use strict';\n\nconst Command = require('cmnd').Command;\nconst APIResource = require('api-res');\nconst Credentials = require('../../credentials.js');\nconst colors = require('colors/safe');\n\nconst async = require('async');\n\nclass PolyCreditsCommand extends Command {\n\n  constructor() {\n\n    super('poly', 'credits');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Shows you your current Polybit Credit balance'\n    };\n\n  }\n\n  run(params, callback) {\n\n    let host = params.flags.h ? params.flags.h[0] : 'https://api.polybit.com';\n    let port = params.flags.p && params.flags.p[0];\n\n    let resource = new APIResource(host, port);\n    resource.authorize(Credentials.read('ACCESS_TOKEN'));\n\n    async.parallel([\n      (callback) => {\n\n        resource.request('v1/users').index({me: true}, (err, response) => {\n\n          if (err) {\n            return callback(`Error: ${err.message}`);\n          }\n\n          if (response.data.length < 1) {\n            return callback(`You are not currently logged in to Polybit.`);\n          }\n\n          let user = response.data[0];\n\n          callback(null, user);\n\n        })\n\n      }\n    ], (err, results) => {\n\n      if (err) {\n        return console.error(err);\n      }\n\n      let user = results[0];\n\n      console.log(`You have ${colors.bold.green(user.credits | 0)} Polybit Credits available.`);\n      callback();\n\n    });\n\n  }\n\n}\n\nmodule.exports = PolyCreditsCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/poly/run.js":"'use strict';\n\nconst Command = require('cmnd').Command;\nconst APIResource = require('api-res');\nconst Credentials = require('../../credentials.js');\n\nconst async = require('async');\n\nclass PolyRunCommand extends Command {\n\n  constructor() {\n\n    super('poly', 'run');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Runs a Nodal command on your deployed project',\n      args: ['project']\n    };\n\n  }\n\n  run(params, callback) {\n\n    let name = params.args[0];\n    let command = params.args[1];\n\n    let host = params.flags.h ? params.flags.h[0] : 'https://api.polybit.com';\n    let port = params.flags.p && params.flags.p[0];\n\n    let resource = new APIResource(host, port);\n    resource.authorize(Credentials.read('ACCESS_TOKEN'));\n\n    async.parallel([\n      (cb) => {\n\n        resource.request('v1/projects').index({name: name}, (err, response) => {\n\n          if (err) {\n            return cb(err);\n          }\n\n          if (response.data.length < 1) {\n            return cb(new Error(`Could not run command: Project \"${name}\" does not exist.`));\n          }\n\n          let project = response.data[0];\n\n          cb(null, project);\n\n        })\n\n      }\n    ], (err, results) => {\n\n      if (err) {\n        return callback(err);\n      }\n\n      let project = results[0];\n\n      console.log(`Running \"${command}...\"`);\n\n      resource.request('v1/projects').update(project.id, {action: 'command', command: command}, null, (err, response) => {\n\n        if (err) {\n          callback(new Error(`Could not run command: ${err.message}`));\n        }\n\n        console.log(`Ran \"${command}\" successfully!`);\n        callback(null, response.data[0]);\n\n      });\n\n    });\n\n  }\n\n  list(files, filename) {\n\n    let path = process.cwd() + '/' + filename;\n\n    if (!fs.existsSync(path)) {\n      return;\n    }\n\n    let stat = fs.statSync(path);\n\n    if (stat.isDirectory()) {\n      return fs\n        .readdirSync(path)\n        .map(v => `${filename}/${v}`)\n        .reduce(this.list.bind(this), files);\n    }\n\n    files.push(filename);\n    return files;\n\n  }\n\n}\n\nmodule.exports = PolyRunCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/poly/create.js":"'use strict';\n\nconst Command = require('cmnd').Command;\nconst APIResource = require('api-res');\nconst Credentials = require('../../credentials.js');\nconst PolyCreditsCommand = require('./credits.js');\n\nconst async = require('async');\n\nclass PolyCreateCommand extends Command {\n\n  constructor() {\n\n    super('poly', 'create');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Creates a new, empty project',\n      args: ['project']\n    };\n\n  }\n\n  run(params, callback) {\n\n    let data = {};\n    data.name = params.args[0];\n\n    console.log(`Creating project \"${data.name}\"...`);\n\n    let host = params.flags.h ? params.flags.h[0] : 'https://api.polybit.com';\n    let port = params.flags.p && params.flags.p[0];\n\n    let resource = new APIResource(host, port);\n    resource.authorize(Credentials.read('ACCESS_TOKEN'));\n\n    resource.request('/v1/projects').create({}, data, (err, response) => {\n\n      if (err) {\n        return callback(err);\n      }\n\n      console.log('Project created successfully!');\n\n      PolyCreditsCommand.prototype.run({args: [], flags: params.flags, vflags: params.vflags}, () => {\n\n        return callback(null, response.data[0]);\n\n      });\n\n    });\n\n  }\n\n}\n\nmodule.exports = PolyCreateCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/poly/db/assign.js":"'use strict';\n\nconst Command = require('cmnd').Command;\nconst APIResource = require('api-res');\nconst Credentials = require('../../../credentials.js');\n\nconst async = require('async');\n\nclass PolyDBAssignCommand extends Command {\n\n  constructor() {\n\n    super('poly', 'db', 'assign');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Assigns a database to a project',\n      args: ['database', 'project']\n    };\n\n  }\n\n  run(params, callback) {\n\n    let data = {};\n    data.alias = params.args[0] || '';\n    data.project = params.args[1] || '';\n\n    console.log(`Assigning database \"${data.alias}\" to \"${data.project}\"...`);\n\n    let host = params.flags.h ? params.flags.h[0] : 'https://api.polybit.com';\n    let port = params.flags.p && params.flags.p[0];\n\n    let resource = new APIResource(host, port);\n    resource.authorize(Credentials.read('ACCESS_TOKEN'));\n\n    async.parallel([\n      (cb) => {\n\n        resource.request('v1/databases').index({alias: data.alias}, (err, response) => {\n\n          if (err) {\n            return cb(err);\n          }\n\n          if (response.data.length < 1) {\n            return cb(new Error(`Could not assign database: Database with alias \"${data.alias}\" does not exist.`));\n          }\n\n          let userDb = response.data[0];\n          cb(null, userDb);\n\n        })\n      },\n      (cb) => {\n\n        resource.request('v1/projects').index({name: data.project}, (err, response) => {\n\n          if (err) {\n            return cb(err);\n          }\n\n          if (response.data.length < 1) {\n            return cb(new Error(`Could not assign database: Project with name \"${data.project}\" does not exist.`));\n          }\n\n          let project = response.data[0];\n\n          cb(null, project);\n\n        })\n\n      }\n    ], (err, results) => {\n\n      if (err) {\n        return callback(err);\n      }\n\n      let db = results[0];\n      let project = results[1];\n\n      let env = (project.env || '').split('\\n').filter(v => v && v.indexOf('DATABASE_URL=') !== 0);\n      env.push(`DATABASE_URL=${db.url}`);\n      env.push('');\n\n      resource.request('v1/projects').update(project.id, {}, {env: env.join('\\n')}, (err, response) => {\n\n        if (err) {\n          return callback(new Error('Could not assign database: Error setting environment vars'));\n        }\n\n        console.log(`Environment variable DATABASE_URL set for project \"${project.name}\" to database \"${db.alias}\"`);\n        return callback(null, response.data[0]);\n\n      });\n\n    });\n\n  }\n\n}\n\nmodule.exports = PolyDBAssignCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/poly/db/create.js":"'use strict';\n\nconst Command = require('cmnd').Command;\nconst APIResource = require('api-res');\nconst Credentials = require('../../../credentials.js');\nconst PolyCreditsCommand = require('../credits.js');\n\nconst path = require('path');\nconst fs = require('fs');\n\nconst async = require('async');\n\nclass PolyDBCreateCommand extends Command {\n\n  constructor() {\n\n    super('poly', 'db', 'create');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Creates a new database',\n      args: ['name'],\n      vflags: {\n        development: 'Sets your development environment database to this db',\n        test: 'Sets your test environment database to this db',\n      }\n    };\n\n  }\n\n  run(params, callback) {\n\n    let data = {};\n    data.alias = params.args[0];\n\n    console.log(`Creating new database with alias \"${data.alias}\"...`);\n\n    let host = params.flags.h ? params.flags.h[0] : 'https://api.polybit.com';\n    let port = params.flags.p && params.flags.p[0];\n\n    let resource = new APIResource(host, port);\n    resource.authorize(Credentials.read('ACCESS_TOKEN'));\n\n    resource.request('v1/databases').create({}, data, (err, response) => {\n\n      if (err) {\n        return callback(err);\n      }\n\n      console.log('Database created successfully!');\n\n      PolyCreditsCommand.prototype.run({args: [], flags: params.flags, vflags: params.vflags}, () => {\n\n        let cfgPath = path.join(process.cwd(), 'config', 'db.json');\n        let db = require(cfgPath);\n\n        if (params.vflags.development) {\n\n          db.development.main = {connectionString: response.data[0].url};\n          fs.writeFileSync(cfgPath, JSON.stringify(db, null, 2));\n\n        } else if (params.vflags.test) {\n\n          db.test.main = {connectionString: response.data[0].url};\n          fs.writeFileSync(cfgPath, JSON.stringify(db, null, 2));\n\n        }\n\n        return callback(null, response.data[0]);\n\n      });\n\n    });\n\n  }\n\n}\n\nmodule.exports = PolyDBCreateCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/poly/db/drop.js":"'use strict';\n\nconst Command = require('cmnd').Command;\nconst APIResource = require('api-res');\nconst Credentials = require('../../../credentials.js');\n\nconst async = require('async');\n\nclass PolyDBDropCommand extends Command {\n\n  constructor() {\n\n    super('poly', 'db', 'drop');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Destroys a database',\n      args: ['db']\n    };\n\n  }\n\n  run(params, callback) {\n\n    let data = {};\n    data.name = params.args[0];\n\n    console.log(`Destroying database ${data.name}...`);\n\n    let host = params.flags.h ? params.flags.h[0] : 'https://api.polybit.com';\n    let port = params.flags.p && params.flags.p[0];\n\n    let resource = new APIResource(host, port);\n    resource.authorize(Credentials.read('ACCESS_TOKEN'));\n\n    resource.request('v1/databases').index({name: data.name}, (err, response) => {\n\n      if (err) {\n        return callback(err);\n      }\n\n      if (!response.data.length) {\n        return callback(new Error(`Could not find database with name ${data.name}`));\n      }\n\n      let id = response.data[0].id;\n\n      resource.request('v1/databases').destroy(id, {}, (err, response) => {\n\n        if (err) {\n          return callback(err);\n        }\n\n        return callback(null, `Dropped database \"${response.data[0].name}\" successfully`);\n\n      });\n\n    });\n\n  }\n\n}\n\nmodule.exports = PolyDBDropCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/poly/db/list.js":"'use strict';\n\nconst Command = require('cmnd').Command;\nconst APIResource = require('api-res');\nconst tabler = require('../../../tabler.js');\nconst Credentials = require('../../../credentials.js');\n\nconst async = require('async');\n\nclass PolyDBListCommand extends Command {\n\n  constructor() {\n\n    super('poly', 'db', 'list');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Retrieves a list of all available Polybit databases for current user'\n    };\n\n  }\n\n  run(args, flags, vflags) {\n\n    let name = params.args[0];\n\n    let host = params.flags.h ? params.flags.h[0] : 'https://api.polybit.com';\n    let port = params.flags.p && params.flags.p[0];\n\n    let resource = new APIResource(host, port);\n    resource.authorize(Credentials.read('ACCESS_TOKEN'));\n\n    async.parallel([\n      (callback) => {\n\n        resource.request('v1/databases').index({}, (err, response) => {\n\n          if (err) {\n            return callback(`Error: ${err.message}`);\n          }\n\n          if (response.data.length < 1) {\n            return callback(`No databases available.`);\n          }\n\n          let dbs = response.data;\n\n          callback(null, dbs);\n\n        })\n\n      }\n    ], (err, results) => {\n\n      if (err) {\n        return console.error(err);\n      }\n\n      let dbs = results[0];\n\n      console.log('Current databases:');\n      console.log(tabler(['name', 'created_at'], dbs));\n\n    });\n\n  }\n\n}\n\nmodule.exports = PolyDBListCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/tabler.js":"'use strict';\n\nmodule.exports = (fields, objects) => {\n\n  let sizes = fields.map(f => {\n    let rowSizes = [f.length].concat(objects.map(o => o[f].toString().length));\n    return Math.max.apply(null, rowSizes);\n  });\n\n  return [\n    fields.map((f, i) => ' ' + f + Array(sizes[i] - f.length + 1).join(' ') + ' ').join('|'),\n    fields.map((f, i) => Array(sizes[i] + 3).join('-')).join('|')\n  ].concat(\n    objects.map(o => {\n      return fields.map((f, i) => {\n        let val = o[f].toString();\n        return ' ' + val + Array(sizes[i] - val.length + 1).join(' ') + ' '\n      }).join('|')\n    })\n  ).join('\\n');\n\n};\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/poly/env.js":"'use strict';\n\nconst Command = require('cmnd').Command;\nconst APIResource = require('api-res');\nconst Credentials = require('../../credentials.js');\n\nconst async = require('async');\n\nclass PolyEnvCommand extends Command {\n\n  constructor() {\n\n    super('poly', 'env');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Retrieves, sets or removes environment variables for a project',\n      args: ['project'],\n      flags: {\n        s: '[key] [value] Sets an environment variable',\n        r: '[key] Removes an environment variable'\n      },\n      vflags: {\n        set: '[key] [value] Sets an environment variable',\n        remove: '[key] Removes an environment variable'\n      }\n    };\n\n  }\n\n  run(params, callback) {\n\n    let name = params.args[0];\n    let set = params.flags.s || params.vflags.set;\n    let remove = params.flags.r || params.vflags.remove;\n\n    let host = params.flags.h ? params.flags.h[0] : 'https://api.polybit.com';\n    let port = params.flags.p && params.flags.p[0];\n\n    let resource = new APIResource(host, port);\n    resource.authorize(Credentials.read('ACCESS_TOKEN'));\n\n    async.parallel([\n      (cb) => {\n\n        resource.request('v1/projects').index({name: name}, (err, response) => {\n\n          if (err) {\n            return cb(err);\n          }\n\n          if (response.data.length < 1) {\n            return cb(new Error(`Project with name \"${name}\" does not exist.`));\n          }\n\n          let project = response.data[0];\n\n          cb(null, project);\n\n        })\n\n      }\n    ], (err, results) => {\n\n      if (err) {\n        return callback(err);\n      }\n\n      let project = results[0];\n\n      let env = (project.env || '').split('\\n').filter(v => v);\n\n      if (remove) {\n        env = env.filter(v => v && v.indexOf(remove[0] + '=') !== 0);\n      }\n\n      if (set) {\n        env = env.filter(v => v && v.indexOf(set[0] + '=') !== 0);\n        env.push(`${set[0]}=${set[1]}`);\n      }\n\n      env.push('');\n\n      resource.request('v1/projects').update(project.id, {}, {env: env.join('\\n')}, (err, response) => {\n\n        if (err) {\n          return console.error('Error setting environment vars');\n        }\n\n        let project = response.data[0];\n\n        console.log(`Environment variables for ${project.name}:`);\n        console.log(project.env);\n\n      });\n\n    });\n\n  }\n\n}\n\nmodule.exports = PolyEnvCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/poly/list.js":"'use strict';\n\nconst Command = require('cmnd').Command;\nconst APIResource = require('api-res');\nconst tabler = require('../../tabler.js');\nconst Credentials = require('../../credentials.js');\n\nconst async = require('async');\n\nclass PolyListCommand extends Command {\n\n  constructor() {\n\n    super('poly', 'list');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Retrieves a list of all available Polybit projects for current user'\n    };\n\n  }\n\n  run(args, flags, vflags) {\n\n    let host = params.flags.h ? params.flags.h[0] : 'https://api.polybit.com';\n    let port = params.flags.p && params.flags.p[0];\n\n    let resource = new APIResource(host, port);\n    resource.authorize(Credentials.read('ACCESS_TOKEN'));\n\n    async.parallel([\n      (callback) => {\n\n        resource.request('v1/projects').index({}, (err, response) => {\n\n          if (err) {\n            return callback(`Error: ${err.message}`);\n          }\n\n          if (response.data.length < 1) {\n            return callback(`No projects available.`);\n          }\n\n          let projects = response.data;\n\n          callback(null, projects);\n\n        })\n\n      }\n    ], (err, results) => {\n\n      if (err) {\n        return console.error(err);\n      }\n\n      let projects = results[0];\n\n      console.log('Available projects:');\n      console.log(tabler(['name', 'service_type', 'created_at'], projects));\n\n    });\n\n  }\n\n}\n\nmodule.exports = PolyListCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/poly/login.js":"'use strict';\n\nconst Command = require('cmnd').Command;\nconst APIResource = require('api-res');\nconst Credentials = require('../../credentials.js');\n\nconst inquirer = require('inquirer');\nconst async = require('async');\n\nclass PolyLoginCommand extends Command {\n\n  constructor() {\n\n    super('poly', 'login');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Logs in to Polybit API server'\n    };\n\n  }\n\n  run(params, callback) {\n\n    let host = params.flags.h ? params.flags.h[0] : 'https://api.polybit.com';\n    let port = params.flags.p && params.flags.p[0];\n\n    let email = params.vflags.email && params.vflags.email[0];\n    let password = params.vflags.password && params.vflags.password[0];\n\n    let questions = [];\n\n    email || questions.push({\n      name: 'email',\n      type: 'input',\n      default: '',\n      message: 'e-mail',\n    });\n\n    password || questions.push({\n      name: 'password',\n      type: 'password',\n      message: 'password',\n    });\n\n    inquirer.prompt(questions, (promptResult) => {\n\n      email = email || promptResult.email;\n      password = password || promptResult.password;\n\n      let resource = new APIResource(host, port);\n\n      resource.request('v1/access_tokens').create({}, {grant_type: 'password', username: email, password: password}, (err, response) => {\n\n        if (err) {\n          return callback(err);\n        }\n\n        Credentials.write('ACCESS_TOKEN', response.data[0].access_token);\n        return callback(null, 'Logged in successfully');\n\n      });\n\n    });\n\n  }\n\n}\n\nmodule.exports = PolyLoginCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/poly/logout.js":"'use strict';\n\nconst Command = require('cmnd').Command;\nconst APIResource = require('api-res');\nconst Credentials = require('../../credentials.js');\n\nconst async = require('async');\n\nclass PolyLogoutCommand extends Command {\n\n  constructor() {\n\n    super('poly', 'logout');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Logs out of Polybit API server'\n    };\n\n  }\n\n  run(params, callback) {\n\n    let host = params.flags.h ? params.flags.h[0] : 'https://api.polybit.com';\n    let port = params.flags.p && params.flags.p[0];\n\n    let resource = new APIResource(host, port);\n    resource.authorize(Credentials.read('ACCESS_TOKEN'));\n\n    resource.request('v1/access_tokens').destroy(null, {}, (err, response) => {\n\n      if (err) {\n        return callback(err);\n      }\n\n      Credentials.write('ACCESS_TOKEN', '');\n      return callback(null, 'Logged out successfully');\n\n    });\n\n  }\n\n}\n\nmodule.exports = PolyLogoutCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/poly/new.js":"'use strict';\n\nconst Command = require('cmnd').Command;\nconst async = require('async');\nconst fs = require('fs');\nconst path = require('path');\n\nconst PolyCreateCommand = require('./create.js');\nconst PolyDBCreateCommand = require('./db/create.js');\nconst PolyDBAssignCommand = require('./db/assign.js');\nconst PolyCompileCommand = require('./compile.js');\n\nclass PolyNewCommand extends Command {\n\n  constructor() {\n\n    super('poly', 'new');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Creates a new API project with associated database',\n      args: ['projectName']\n    };\n\n  }\n\n  run(params, callback) {\n\n    let name = params.args[0];\n\n    // for PolyCompileCommand\n    params.vflags.prepare = true;\n\n    if (!fs.existsSync(path.join(process.cwd(), '.nodal'))) {\n      return callback(new Error('Must run `nodal poly:new` from a valid Nodal project. Please try `nodal new` first.'));\n    }\n\n    async.series([\n      cb => PolyCreateCommand.prototype.run({args: [name], flags: params.flags, vflags: params.vflags}, cb),\n      cb => PolyDBCreateCommand.prototype.run({args: [name], flags: params.flags, vflags: params.vflags}, cb),\n      cb => PolyDBAssignCommand.prototype.run({args: [name, name], flags: params.flags, vflags: params.vflags}, cb),\n      cb => PolyCompileCommand.prototype.run({args: [name], flags: params.flags, vflags: params.vflags}, cb)\n    ], (err) => {\n\n      if (err) {\n        return callback(err);\n      }\n\n      console.log('Project created successfully!');\n\n    });\n\n  }\n\n}\n\nmodule.exports = PolyNewCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/poly/register.js":"'use strict';\n\nconst Command = require('cmnd').Command;\nconst APIResource = require('api-res');\nconst Credentials = require('../../credentials.js');\n\nconst colors = require('colors/safe');\nconst inquirer = require('inquirer');\nconst async = require('async');\n\nclass PolyRegisterCommand extends Command {\n\n  constructor() {\n\n    super('poly', 'register');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Registers a new Polybit User Account'\n    };\n\n  }\n\n  run(params, callback) {\n\n    let host = params.flags.h ? params.flags.h[0] : 'https://api.polybit.com';\n    let port = params.flags.p && params.flags.p[0];\n\n    let questions = [];\n\n    console.log('');\n    console.log(colors.bold.green('Welcome to Polybit Cloud!'));\n    console.log('https://www.polybit.com/');\n    console.log('');\n    console.log('Polybit Cloud is an API Deployment Platform built for Nodal.');\n    console.log('Please ensure you use a valid e-mail address.');\n    console.log(colors.bold.red('Accounts with invalid e-mails may be removed without warning.'));\n    console.log('');\n    console.log('Enjoy! :)');\n    console.log('');\n\n    questions.push({\n      name: 'email',\n      type: 'input',\n      default: '',\n      message: 'e-mail',\n    });\n\n    questions.push({\n      name: 'password',\n      type: 'password',\n      message: 'password',\n    });\n\n    questions.push({\n      name: 'repeat_password',\n      type: 'password',\n      message: 'repeat password',\n    });\n\n    inquirer.prompt(questions, (promptResult) => {\n\n      let email = promptResult.email;\n      let password = promptResult.password;\n      let repeat = promptResult.repeat_password;\n\n\n      let resource = new APIResource(host, port);\n      resource.request('v1/users').create({}, {email: email, password: password, repeat_password: repeat}, (err, response) => {\n\n        if (err) {\n          return callback(err);\n        }\n\n        require('./login.js').prototype.run({\n          args: params.args,\n          flags: params.flags,\n          vflags: {email: [email], password: [password]}\n        }, callback);\n\n      });\n\n    });\n\n  }\n\n}\n\nmodule.exports = PolyRegisterCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/poly/remove.js":"'use strict';\n\nconst Command = require('cmnd').Command;\nconst APIResource = require('api-res');\nconst Credentials = require('../../credentials.js');\n\nconst async = require('async');\n\nclass PolyRemoveCommand extends Command {\n\n  constructor() {\n\n    super('poly', 'remove');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Removes a project',\n      args: ['project']\n    };\n\n  }\n\n  run(params, callback) {\n\n    let data = {};\n    data.name = params.args[0];\n\n    console.log(`Destroying project ${data.name}...`);\n\n    let host = params.flags.h ? params.flags.h[0] : 'https://api.polybit.com';\n    let port = params.flags.p && params.flags.p[0];\n\n    let resource = new APIResource(host, port);\n    resource.authorize(Credentials.read('ACCESS_TOKEN'));\n\n    resource.request('v1/projects').index({name: data.name}, (err, response) => {\n\n      if (err) {\n        return callback(err);\n      }\n\n      if (!response.data.length) {\n        return callback(new Error(`Could not find project with name ${data.name}`));\n      }\n\n      let id = response.data[0].id;\n\n      resource.request('v1/projects').destroy(id, {}, (err, response) => {\n\n        if (err) {\n          return callback(err);\n        }\n\n        return callback(null, `Destroyed project ${response.data[0].name} successfully`);\n\n      });\n\n    });\n\n  }\n\n}\n\nmodule.exports = PolyRemoveCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/s.js":"'use strict';\n\nconst Command = require('cmnd').Command;\n\nclass ServerCommand extends Command {\n\n  constructor() {\n\n    super('s');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Starts your Nodal Server'\n    };\n\n  }\n\n  run(params, callback) {\n\n    let spawn = require('cross-spawn-async');\n    let child = spawn('npm',  ['start'], {stdio: 'inherit'});\n\n    process.on('exit', function() {\n      child && child.kill();\n    });\n\n  }\n\n}\n\nmodule.exports = ServerCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/task.js":"'use strict';\n\nconst Command = require('cmnd').Command;\n\nconst fs = require('fs');\nconst colors = require('colors/safe');\n\nclass TaskCommand extends Command {\n\n  constructor() {\n\n    super('task');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Runs the named task',\n      args: ['task name']\n    };\n\n  }\n\n  run(params, callback) {\n\n    let taskName = params.args[0] || '';\n    let cwd = process.cwd();\n    let taskPath = cwd + '/tasks/' + taskName + '.js';\n\n    if (!fs.existsSync(taskPath)) callback(new Error('Task \"' + taskName + '\" does not exist'));\n\n    const Task = require(taskPath);\n    let task = new Task();\n\n    task.exec(params.args.slice(1), (err) => {\n\n      if (err) {\n        console.log(`${colors.red.bold('Task Error:')} ${err.message}`);\n      } else {\n        console.log('Task complete!');\n      }\n\n      callback(null);\n\n    });\n\n  }\n\n}\n\nmodule.exports = TaskCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/commands/version.js":"'use strict';\n\nconst Command = require('cmnd').Command;\nconst colors = require('colors/safe');\n\nclass VersionCommand extends Command {\n\n  constructor() {\n\n    super('version');\n\n  }\n\n  help() {\n\n    return {\n      description: 'Shows your currently globally installed Nodal version'\n    };\n\n  }\n\n  run(params, callback) {\n\n    let version = require('../../package.json').version;\n    console.log(colors.green.bold('Nodal Version: ') + version);\n\n    callback(null);\n\n  }\n\n}\n\nmodule.exports = VersionCommand;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/required/daemon.js":"'use strict';\n\nconst fxn = require('fxn');\n\nconst API = require('./api.js');\n\n/**\n* Multi-process HTTP Daemon that resets when files changed (in development)\n* @class\n*/\nclass Daemon extends fxn.Daemon {\n\n  constructor(cpus) {\n\n    super('Nodal', cpus);\n\n  }\n\n  error(req, res, err) {\n\n    res.writeHead(500, {'Content-Type': 'text/plain'});\n\n    res.end(\n      JSON.stringify(\n        API.error(\n          'Application Error',\n          (process.env.NODE_ENV !== 'production' && err) ?\n            err.stack.split('\\n') : null\n          ),\n        null,\n        2\n      )\n    );\n\n  }\n\n}\n\nmodule.exports = Daemon;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/required/graph_query.js":"'use strict';\n\nconst inflect = require('i')();\nconst API = require('./api.js');\n\n/**\n* GraphQuery class that translates GraphQL to something digestible by the Composer\n* @class\n*/\nclass GraphQuery {\n\n  /**\n  * Create a GraphQuery object\n  * @param {String} str The query to execute\n  * @param {Number} maxDepth The maximum depth of graph to traverse\n  * @param {Nodal.Model} [Model=null] The Model to base your query around (used for testing)\n  */\n  constructor(str, maxDepth, Model) {\n\n    let parsed = this.constructor.parse(str, maxDepth);\n\n    this.identifier = typeof parsed.structure === 'string' ?\n      parsed.structure :\n      Object.keys(parsed.structure)[0];\n    this.name = inflect.singularize(this.identifier);\n\n    try {\n      this.Model = Model || require(`${process.cwd()}/app/models/${this.name}.js`);\n    } catch(e) {\n      throw new Error(`Model ${this.name} does not exist.`);\n    }\n\n    this.structure = parsed.structure;\n    this.joins = parsed.joins;\n\n  }\n\n  /**\n  * Create and execute a GraphQuery object\n  * @param {String} str The query to execute\n  * @param {Number} maxDepth The maximum depth of graph to traverse\n  * @param {Function} callback The function to execute upon completion\n  */\n  static query(str, maxDepth, callback) {\n\n    let graphQuery;\n\n    try {\n      graphQuery = new GraphQuery(str, maxDepth);\n    } catch (err) {\n      callback(err);\n      return false;\n    }\n\n    graphQuery.query(callback);\n\n    return true;\n\n  }\n\n  /**\n  * Parse syntax tree of a GraphQL query\n  */\n  static parseSyntaxTree(str, state, arr) {\n\n    arr = arr || [];\n    state = state || 'NAME';\n\n    let punc = '():{},';\n    let nameRE = /[_A-Za-z][_0-9A-Za-z]*/;\n\n    const STATES = {\n      'NAME': {\n        skip: false,\n        terminate: true,\n        next: 'PROPERTYLIST',\n        func: (str, arr) => {\n\n          let match = str.match(nameRE);\n          let name = match ? match[0] : null;\n\n          arr.push({\n            type: 'field',\n            data: {\n              name: name\n            }\n          });\n\n          let len = name ? name.length : 0;\n          return str.substr(len);\n\n        }\n      },\n      'PROPERTYNAME': {\n        skip: false,\n        terminate: true,\n        next: 'PROPERTYVALUESTART',\n        func: (str, arr) => {\n\n          let match = str.match(nameRE);\n          let name = match ? match[0] : null;\n\n          arr.push({\n            type: 'property',\n            data: {\n              name: name\n            }\n          });\n\n          let len = name ? name.length : 0;\n          return str.substr(len);\n\n        }\n      },\n      'PROPERTYVALUESTART': {\n        skip: false,\n        terminate: false,\n        next: 'PROPERTYVALUE',\n        func: (str, arr) => {\n\n          if (str[0] !== ':') {\n            return str;\n          }\n\n          return str.substr(1);\n\n        }\n      },\n      'PROPERTYVALUE': {\n        skip: false,\n        terminate: false,\n        next: 'PROPERTYVALUEEND',\n        func: (str, arr) => {\n\n          let cur = arr[arr.length - 1];\n\n          if (str[0] !== '\"') {\n\n            let items = [\n              {str: 'null', val: null},\n              {str: 'true', val: true},\n              {str: 'false', val: false}\n            ];\n\n            for (let i = 0; i < items.length; i++) {\n              let item = items[i];\n              if (str.substr(0, item.str.length) === item.str) {\n                cur.data.value = item.val;\n                return str.substr(item.str.length);\n              }\n            }\n\n            let value = str.match(/^[\\-\\+]?\\d+(\\.\\d+|e[\\-\\+]?\\d+)?/i);\n\n            if (!value) {\n              return str;\n            }\n\n            value = value[0];\n            cur.data.value = parseFloat(value);\n            return str.substr(value.length);\n\n          }\n\n          let i = 1;\n          while (str[i]) {\n\n            if (str[i] === '\"') {\n\n              let n = 1;\n              let c = 0;\n\n              while (str[i - n] === '\\\\') {\n                c++;\n                n++;\n              }\n\n              if (!(c & 1)) {\n                cur.data.value = str.substring(1, i);\n                return str.substring(i + 1);\n              }\n\n            }\n\n            i++;\n\n          }\n\n          return str;\n\n        }\n      },\n      'PROPERTYVALUEEND': {\n        skip: false,\n        terminate: true,\n        next: 'PROPERTYNAME',\n        func: (str, arr) => {\n\n          if (str[0] !== ',') {\n            return str;\n          }\n\n          return str.substr(1);\n\n        }\n      },\n      'PROPERTYLIST': {\n        skip: true,\n        terminate: true,\n        func: (str, arr) => {\n\n          if (str[0] !== '(') {\n            return str;\n          }\n\n          let cur = arr[arr.length - 1];\n\n          let count = 0;\n          let i = 0;\n\n          while (str[i]) {\n            if (str[i] === '(') {\n              count++;\n            } else if (str[i] === ')') {\n              count--;\n            }\n            if (!count) {\n              break;\n            }\n            i++;\n          }\n\n          if (count) {\n            return str;\n          }\n\n          cur.data.properties = this.parseSyntaxTree(str.substring(1, i), 'PROPERTYNAME');\n\n          return str.substring(i + 1);\n\n        },\n        next: 'LIST'\n      },\n      'LIST': {\n        skip: true,\n        terminate: true,\n        next: 'NAMEEND',\n        func: (str, arr) => {\n\n          if (str[0] !== '{') {\n            return str;\n          }\n\n          let cur = arr[arr.length - 1];\n\n          let count = 0;\n          let i = 0;\n\n          while (str[i]) {\n            if (str[i] === '{') {\n              count++;\n            } else if (str[i] === '}') {\n              count--;\n            }\n            if (!count) {\n              break;\n            }\n            i++;\n          }\n\n          if (count) {\n            return str;\n          }\n\n          cur.data.children = this.parseSyntaxTree(str.substring(1, i), 'NAME');\n\n          return str.substring(i + 1);\n\n        }\n      },\n      'NAMEEND': {\n        skip: false,\n        terminate: true,\n        next: 'NAME',\n        func: (str, arr) => {\n\n          if (str[0] !== ',') {\n            return str;\n          }\n\n          return str.substr(1);\n\n        }\n      }\n    };\n\n    /* State machine... */\n\n    str = str.replace(/^\\s*(.*)$/m, '$1');\n\n    if (!str) {\n      if (STATES[state].terminate) {\n        return arr;\n      } else {\n        throw new Error('Unexpected termination');\n      }\n    }\n\n    // Execute next step...\n    let next = STATES[state].func(str, arr);\n\n    if (!STATES[state].skip && (next === str)) {\n      throw new Error(`Syntax Error at or near \"${str.substr(0, 20)}\"`);\n    }\n\n    if (!STATES[state].next) {\n      return arr;\n    }\n\n    return this.parseSyntaxTree(next, STATES[state].next, arr);\n\n  }\n\n  /**\n  * Fully parse a GraphQL query, get necessary joins to make in SQL\n  */\n  static parse(str, max) {\n\n    let joins = {};\n    let tree = this.formatTree(\n      this.parseSyntaxTree(str),\n      max,\n      joins\n    );\n\n    if (!tree.length) {\n      throw new Error('Invalid query: List an object to query');\n    }\n\n    return {\n      structure: tree[0],\n      joins: joins\n    };\n\n  }\n\n  /**\n  * Format a parsed syntax tree in a way that the Composer expects\n  */\n  static formatTree(tree, max, joins, parents) {\n\n    max = Math.max(max | 0, 0);\n    joins = joins || {};\n    parents = parents || [];\n\n    let depth = parents.length;\n\n    return tree.map(item => {\n\n      joins[parents.concat(item.data.name).join('__')] = (item.data.properties || [])\n        .filter(p => p.type === 'property')\n        .reduce((obj, p) => {\n          obj[p.data.name] = p.data.value;\n          return obj;\n        }, {});\n\n      if (!item.data.children) {\n\n        return item.data.name;\n\n      }\n\n      if (!max || depth < max) {\n\n        let nameObj = {};\n        nameObj[item.data.name] = this.formatTree(\n          item.data.children || [],\n          max,\n          joins,\n          parents.concat(item.data.name)\n        );\n\n        return nameObj;\n\n      } else {\n\n        return null;\n\n      }\n\n    }).filter(item => item);\n\n  }\n\n  /**\n  * Query the GraphQuery object from the database\n  * @param {Function} callback The function to execute upon completion\n  */\n  query(callback) {\n\n    let query = this.Model.query().safeWhere(this.joins[this.identifier]);\n\n    Object.keys(this.joins).forEach(joinName => {\n\n      let joinNames = joinName.split('__');\n      joinNames.shift();\n      if (!joinNames.length) {\n        return;\n      }\n\n      query = query.safeJoin(joinNames.join('__'), this.joins[joinName]);\n\n    });\n\n    query.end((err, models) => {\n\n      callback(err, models, this.structure[this.identifier]);\n\n    });\n\n    return this;\n\n  }\n\n}\n\nmodule.exports = GraphQuery;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/required/db/migration.js":"'use strict';\n\nconst Database = require('./database.js');\nconst SchemaGenerator = require('./schema_generator.js');\n\nconst fs = require('fs');\n\nconst colors = require('colors/safe');\nconst inflect = require('i')();\n\nclass Migration {\n\n  constructor(db) {\n\n    if (!db) {\n      throw new Error('Migration required valid database instance');\n    }\n\n    this.id = null;\n\n    this.db = db;\n\n    this.schema = new SchemaGenerator(db);\n\n  }\n\n  up() {\n\n    return [];\n\n  }\n\n  down() {\n\n    return [];\n\n  }\n\n  executeUp(callback) {\n\n    let schema = this.schema;\n\n    schema.fetch((function(err) {\n\n      if (err) {\n        return callback(err);\n      }\n\n      schema.setMigrationId(this.id);\n\n      let up = this.up().concat([\n        'INSERT INTO \"schema_migrations\"(\"id\", \"schema\") VALUES(' + this.id + ', \\'' + schema.generate() + '\\')'\n      ]);\n\n      this.db.transaction(up.join(';'), function(err) {\n        !err && schema.save();\n        return callback(err);\n      });\n\n    }).bind(this));\n\n  }\n\n  executeDown(callback, prevId) {\n\n    let schema = this.schema;\n\n    schema.fetch((function(err) {\n\n      if (err) {\n        return callback(err);\n      }\n\n      schema.setMigrationId(prevId || null);\n\n      let down = this.down().concat([\n        'DELETE FROM \"schema_migrations\" WHERE id = ' + this.id\n      ]);\n\n      this.db.transaction(down.join(';'), function(err) {\n        !err && schema.save();\n        callback(err);\n      });\n\n    }).bind(this));\n\n  }\n\n  createTable(table, arrFieldData, modelName) {\n\n    arrFieldData = this.schema.createTable(table, arrFieldData, modelName);\n\n    return this.db.adapter.generateCreateTableQuery(table, arrFieldData);\n\n  }\n\n  dropTable(table) {\n\n    this.schema.dropTable(table);\n\n    return this.db.adapter.generateDropTableQuery(table);\n\n  }\n\n  renameTable(table, newTableName, renameModel, newModelName) {\n\n    let modelSchema = this.schema.renameTable(table, newTableName, renameModel, newModelName);\n\n    return this.db.adapter.generateAlterTableRename(table, newTableName, modelSchema.columns);\n\n  }\n\n  alterColumn(table, column, type, properties) {\n\n    properties = properties || {};\n\n    this.schema.alterColumn(table, column, type, properties);\n\n    return this.db.adapter.generateAlterTableQuery(table, column, type, properties);\n\n  }\n\n  addColumn(table, column, type, properties) {\n\n    properties = properties || {};\n\n    this.schema.addColumn(table, column, type, properties);\n\n    return this.db.adapter.generateAlterTableAddColumnQuery(table, column, type, properties);\n\n  }\n\n  dropColumn(table, column) {\n\n    this.schema.dropColumn(table, column);\n\n    return this.db.adapter.generateAlterTableDropColumnQuery(table, column);\n\n  }\n\n  renameColumn(table, column, newColumn) {\n\n    this.schema.renameColumn(table, column, newColumn);\n\n    return this.db.adapter.generateAlterTableRenameColumnQuery(table, column, newColumn);\n\n  }\n\n  createIndex(table, column, type) {\n\n    this.schema.createIndex(table, column, type);\n\n    return this.db.adapter.generateCreateIndexQuery(table, column, type);\n\n  }\n\n  dropIndex(table, column) {\n\n    this.schema.dropIndex(table, column);\n\n    return this.db.adapter.generateDropIndexQuery(table, column);\n\n  }\n\n  addForeignKey(table, referenceTable) {\n\n    if (this.db.adapter.supportsForeignKey) {\n      this.schema.addForeignKey(table, referenceTable);\n      return this.db.adapter.generateSimpleForeignKeyQuery(table, referenceTable);\n    } else {\n      throw new Error(`${this.db.adapter.constructor.name} does not support foreign keys`);\n    }\n\n  }\n\n  dropForeignKey(table, referenceTable) {\n\n    if (this.db.adapter.supportsForeignKey) {\n      this.schema.dropForeignKey(table, referenceTable);\n      return this.db.adapter.generateDropSimpleForeignKeyQuery(table, referenceTable);\n    } else {\n      throw new Error(`${this.db.adapter.constructor.name} does not support foreign keys`);\n    }\n  }\n\n\n};\n\nmodule.exports = Migration;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/required/db/schema_generator.js":"'use strict';\n\nconst fs = require('fs');\nconst inflect = require('i')();\n\nclass SchemaGenerator {\n\n  constructor(db) {\n\n    this.db = db;\n\n    this.migrationId = null;\n    this.models = {};\n    this.indices = [];\n\n    this._defaultPath = 'db/schema.json';\n\n  }\n\n  load(filename) {\n    filename = filename || this._defaultPath;\n    filename = process.cwd() + '/' + filename;\n    return this.read(fs.readFileSync(filename));\n  }\n\n  fetch(callback) {\n\n    this.db.query('SELECT \"schema_migrations\".\"schema\" FROM \"schema_migrations\" ORDER BY \"id\" DESC LIMIT 1', [], (function(err, result) {\n\n      if (err) {\n        return callback(err);\n      }\n\n      result.rows && result.rows.length && this.read(result.rows[0].schema);\n\n      callback(null);\n\n    }).bind(this));\n\n  }\n\n  save(filename) {\n    filename = filename || this._defaultPath;\n    filename = process.cwd() + '/' + filename;\n    fs.writeFileSync(filename, this.generate());\n    return true;\n  }\n\n  mergeProperties(columnData, properties) {\n\n    properties = properties || {};\n\n    let defaults = this.db.adapter.typePropertyDefaults;\n\n    let oldProperties = this.db.adapter.getTypeProperties(columnData.type, columnData.properties) || {};\n    let newProperties = {};\n\n    this.db.adapter.typeProperties.forEach(function(v) {\n      if (properties.hasOwnProperty(v) && properties[v] !== defaults[v]) {\n        newProperties[v] = properties[v];\n      } else if (oldProperties.hasOwnProperty(v) && oldProperties[v] !== defaults[v]) {\n        newProperties[v] = oldProperties[v];\n      }\n    });\n\n    columnData.properties = newProperties;\n\n    return columnData;\n\n  }\n\n  set(schema) {\n\n    this.setMigrationId(schema.migration_id);\n    this.models = schema.models || {};\n    this.indices = schema.indices || [];\n\n    return true;\n\n  }\n\n  setMigrationId(id) {\n    this.migrationId = id;\n  }\n\n  findClass(table) {\n\n    let models = this.models;\n    return Object.keys(models).filter(function(v) {\n      return models[v].table === table;\n    }).pop();\n\n  }\n\n  createTable(table, arrColumnData, modelName) {\n\n    let tableClass = modelName || inflect.classify(table);\n\n    if (this.models[tableClass]) {\n      throw new Error('Model with name \"' + tableClass + '\" already exists in your schema');\n    }\n\n    if (this.findClass(table)) {\n      throw new Error('Table with name \"' + table + '\" already exists in your schema.');\n    }\n\n    arrColumnData = arrColumnData.slice();\n\n    let columns = arrColumnData.map(function(v) {\n      return v.name;\n    });\n\n    if (columns.indexOf('id') === -1) {\n      arrColumnData.unshift({name: 'id', type: 'serial'});\n    }\n\n    if (columns.indexOf('created_at') === -1) {\n      arrColumnData.push({name:'created_at', type: 'datetime'});\n    }\n\n    if (columns.indexOf('updated_at') === -1) {\n      arrColumnData.push({name:'updated_at', type: 'datetime'});\n    }\n\n    let defaults = this.db.adapter.typePropertyDefaults;\n\n    arrColumnData.forEach((function(columnData) {\n      this.mergeProperties(columnData);\n    }).bind(this));\n\n    this.models[tableClass] = {\n      table: table,\n      columns: arrColumnData\n    };\n\n    return arrColumnData;\n\n  }\n\n  dropTable(table) {\n\n    let tableClass = this.findClass(table);\n\n    if (!tableClass) {\n      throw new Error('Table \"' + table + '\" does not exist in your schema');\n    }\n\n    delete this.models[tableClass];\n\n    return true;\n\n  }\n\n  renameTable(table, newTableName, renameModel, newModelName) {\n\n    let tableClass = this.findClass(table);\n\n    if (!tableClass) {\n      throw new Error('Table \"' + table + '\" does not exist in your schema');\n    }\n\n    this.models[tableClass].table = newTableName;\n\n    if (renameModel) {\n      let newClass = newModelName || inflect.classify(newTableName);\n      this.models[newClass] = this.models[tableClass];\n      delete this.models[tableClass];\n      tableClass = newClass;\n    }\n\n    return this.models[tableClass];\n\n  }\n\n  alterColumn(table, column, type, properties) {\n\n    if (properties.primary_key) {\n      delete properties.unique;\n    }\n\n    let models = this.models;\n    let modelKey = Object.keys(models).filter(function(t) {\n      return models[t].table === table;\n    }).pop();\n\n    if (!modelKey) {\n      throw new Error('Table \"' + table + '\" does not exist');\n    }\n\n    let schemaFieldData = models[modelKey].columns.filter(function(v) {\n      return v.name === column;\n    }).pop();\n\n    if (!schemaFieldData) {\n      throw new Error('Column \"' + column + '\" of table \"' + table + '\" does not exist');\n    }\n\n    schemaFieldData.type = type;\n\n    this.mergeProperties(schemaFieldData, properties);\n\n    return true;\n\n  }\n\n  addColumn(table, column, type, properties) {\n\n    if (properties.primary_key) {\n      delete properties.unique;\n    }\n\n    let models = this.models;\n    let modelKey = Object.keys(models).filter(function(t) {\n      return models[t].table === table;\n    }).pop();\n\n    if (!modelKey) {\n      throw new Error('Table \"' + table + '\" does not exist');\n    }\n\n    let modelSchema = models[modelKey];\n\n    let schemaFieldData = modelSchema.columns.filter(function(v) {\n      return v.name === column;\n    }).pop();\n\n    if (schemaFieldData) {\n      throw new Error('Column \"' + column + '\" of table \"' + table + '\" already exists');\n    }\n\n    let columnData = {\n      name: column,\n      type: type,\n      properties: properties\n    };\n\n    modelSchema.columns.push(columnData);\n\n    return true;\n\n  }\n\n  dropColumn(table, column) {\n\n    let models = this.models;\n    let modelKey = Object.keys(models).filter(function(t) {\n      return models[t].table === table;\n    }).pop();\n\n    if (!modelKey) {\n      throw new Error('Table \"' + table + '\" does not exist');\n    }\n\n    let modelSchema = models[modelKey];\n\n    let columnIndex = modelSchema.columns.map(function(v, i) { return v.name; }).indexOf(column);\n\n    if (columnIndex === -1) {\n      throw new Error('Column \"' + column + '\" of table \"' + table + '\" does not exist');\n    }\n\n    modelSchema.columns.splice(columnIndex, 1);\n\n    return true;\n\n  }\n\n  renameColumn(table, column, newColumn) {\n\n    let models = this.models;\n    let modelKey = Object.keys(models).filter(function(t) {\n      return models[t].table === table;\n    }).pop();\n\n    if (!modelKey) {\n      throw new Error('Table \"' + table + '\" does not exist');\n    }\n\n    let modelSchema = models[modelKey];\n\n    let schemaFieldData = modelSchema.columns.filter(function(v) {\n      return v.name === column;\n    }).pop();\n\n    if (!schemaFieldData) {\n      throw new Error('Column \"' + column + '\" of table \"' + table + '\" already exists');\n    }\n\n    schemaFieldData.name = newColumn;\n\n    return true;\n\n  }\n\n  createIndex(table, column, type) {\n\n    if (this.indices.filter(function(v) {\n      return v.table === table && v.column === column;\n    }).length) {\n      throw new Error(`Index already exists on column \"${column}\" of table \"${table}\"`);\n    }\n\n    this.indices.push({table: table, column: column, type: type});\n\n    return true\n\n  }\n\n  dropIndex(table, column) {\n\n    this.indices = this.indices.filter(function(v) {\n      return !(v.table === table && v.column === column);\n    });\n\n    return true;\n\n  }\n\n  addForeignKey(table, referenceTable) {\n\n    let tableClass = inflect.classify(table);\n    let referenceTableClass = inflect.classify(referenceTable);\n\n    if (!this.models[tableClass]) {\n      throw new Error(`Model ${tableClass} does not exist.`);\n    }\n\n    if (!this.models[referenceTableClass]) {\n      throw new Error(`Model ${referenceTableClass} does not exist.`);\n    }\n\n    return true;\n\n  }\n\n  dropForeignKey(table, referenceTable) {\n\n    let tableClass = inflect.classify(table);\n    let referenceTableClass = inflect.classify(referenceTable);\n\n    if (!this.models[tableClass]) {\n      throw new Error(`Model ${tableClass} does not exist.`);\n    }\n\n    if (!this.models[referenceTableClass]) {\n      throw new Error(`Model ${referenceTableClass} does not exist.`);\n    }\n\n    return true;\n\n  }\n\n  read(json) {\n    return this.set(JSON.parse(json));\n  }\n\n  generate() {\n\n    let models = this.models;\n    let indices = this.indices;\n    let hasModels = !!Object.keys(models).length;\n    let hasIndices = indices.length;\n\n    let fileData = [\n      '{',\n      '',\n      '  \"migration_id\": ' + this.migrationId + ((hasModels || hasIndices) ? ',' : ''),\n    ];\n\n    if (hasIndices) {\n\n      fileData = fileData.concat([\n        '',\n        '  \"indices\": [',\n          indices.map(function(indexData) {\n            return [\n              '    {',\n                [\n                  '\"table\": \"' + indexData.table + '\"',\n                  '\"column\": \"' + indexData.column + '\"',\n                  (indexData.type ? '\"type\": \"' + indexData.type+ '\"' : '')\n                ].filter(function(v) { return !!v; }).join(', '),\n              '}',\n            ].join('');\n          }).join(',\\n'),\n        '  ]' + (hasModels ? ',' : ''),\n      ]);\n\n    }\n\n    if (hasModels) {\n\n      fileData = fileData.concat([\n        '',\n        '  \"models\": {',\n        '',\n        Object.keys(models).sort().map(function(t) {\n          let curTable = models[t];\n          return [\n            '    \"' + t + '\": {',\n            '',\n            '      \"table\": \"' + curTable.table + '\",',\n            '',\n            '      \"columns\": [',\n            curTable.columns.map(function(columnData) {\n              return [\n                '        ',\n                '{',\n                  [\n                    '\"name\": \"' + columnData.name + '\"',\n                    '\"type\": \"' + columnData.type + '\"',\n                    columnData.properties ? '\"properties\": ' + JSON.stringify(columnData.properties) : ''\n                  ].filter(function(v) { return !!v; }).join(', '),\n                '}'\n              ].join('');\n            }).join(',\\n'),\n            '      ]',\n            '',\n            '    }'\n          ].join('\\n');\n        }).join(',\\n\\n'),\n        '',\n        '  }'\n      ]);\n\n    }\n\n    return fileData.concat([\n      '',\n      '}',\n      ''\n    ]).join('\\n');\n\n  }\n\n}\n\nmodule.exports = SchemaGenerator;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/required/mime.js":"module.exports = require('mime-types');\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/required/model_factory.js":"'use strict';\n\nconst ModelArray = require('./model_array.js');\nconst fs = require('fs');\nconst async = require('async');\n\n/**\n* Factory for creating models\n* @class\n*/\nclass ModelFactory {\n\n  /**\n  * Create the ModelFactory with a provided Model to use as a reference.\n  * @param {Nodal.Model} modelConstructor Must pass the constructor for the type of ModelFactory you wish to create.\n  */\n  constructor(modelConstructor) {\n\n    this.Model = modelConstructor;\n\n  }\n\n  /**\n  * Loads all model constructors in your ./app/models directory into an array\n  * @return {Array} Array of model Constructors\n  */\n  static loadModels() {\n\n    let dir = './app/models';\n    if (!fs.existsSync(dir)) {\n      return [];\n    }\n\n    return fs\n      .readdirSync(dir)\n      .filter(filename => filename.indexOf('.') !== 0)\n      .map(filename => require(`${process.cwd()}/app/models/${filename}`))\n\n  }\n\n  /**\n  * Creates new factories from a supplied array of Models, loading in data keyed by Model name\n  * @param {Array} Models Array of model constructors you wish to reference\n  * @param {Object} objModelData Keys are model names, values are arrays of model data you wish to create\n  * @param {Function} callback What to execute upon completion\n  */\n  static createFromModels(Models, objModelData, callback) {\n\n    if (objModelData instanceof Array) {\n      async.series(\n        objModelData.map(objModelData => callback => this.createFromModels(Models, objModelData, callback)),\n        (err, results) => {\n          results = (results || []).reduce((results, res) => {\n            return results.concat(res);\n          }, []);\n          callback(err || null, results);\n        }\n      );\n      return;\n    }\n\n    async.parallel(\n      Models\n        .filter(Model => objModelData[Model.name] && objModelData[Model.name].length)\n        .map(Model => callback => new this(Model).create(objModelData[Model.name], callback)),\n      (err, results) => callback(err || null, results)\n    );\n\n  }\n\n  /**\n  * Populates a large amount of model data from an Object.\n  * @param {Array} Models Array of Model constructors\n  */\n  static populate(objModelData, callback) {\n\n    return this.createFromModels(this.loadModels(), objModelData, callback);\n\n  }\n\n  /**\n  * Creates models from an array of Objects containing the model data\n  * @param {Array} arrModelData Array of objects to create model data from\n  */\n  create(arrModelData, callback) {\n\n    // new this.Model(data, false, true) is telling the Model that this is from a seed\n\n    ModelArray\n      .from(arrModelData.map(data => {\n        return new this.Model(data, false, true);\n      }))\n      .saveAll(callback);\n\n  }\n\n}\n\nmodule.exports = ModelFactory;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/required/router.js":"'use strict';\n\nconst fxn = require('fxn');\n\nclass Router extends fxn.Router {}\n\nmodule.exports = Router;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/required/scheduler.js":"'use strict';\n\nconst fxn = require('fxn');\n\n/**\n* Use to delegate tasks minutely, hourly, daily, or weekly.\n* @class\n*/\nclass Scheduler extends fxn.Scheduler {}\n\nmodule.exports = Scheduler;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/my/config.js":"'use strict';\n\n// Load env anew every time config is loaded\nconst env = require('./../env.js')();\n\nconst fs = require('fs');\nconst path = require('path');\nconst dot = require('dot');\n\nlet config = {};\n\nlet varname = dot.templateSettings.varname;\n\ndot.templateSettings.varname = 'env';\n\nlet dir = path.join(env.rootDirectory, 'config');\nlet configFiles = fs.readdirSync(dir);\n\nconst ext = '.json';\n\nconfigFiles.filter(function(filename) {\n  let name = path.basename(filename, ext);\n  return !config[name] && path.extname(filename) === ext;\n}).forEach(function(filename) {\n\n  let configData;\n\n  try {\n    configData = fs.readFileSync(path.join(dir, filename));\n    configData = dot.template(configData)(process.env);\n    configData = JSON.parse(configData);\n  } catch(e) {\n    throw new Error(`Could not parse \"config/${filename}\": Invalid JSON`);\n  }\n\n  config[path.basename(filename, ext)] = configData[env.name];\n\n});\n\ndot.templateSettings.varname = varname;\n\nmodule.exports = config;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/my/schema.js":"'use strict';\n\nconst env = require('./../env.js')();\nconst fs = require('fs');\n\nlet schema = {};\n\ntry {\n  schema = JSON.parse(fs.readFileSync(env.rootDirectory + '/db/schema.json'));\n} catch(e) {\n  schema = {migration_id: null};\n}\n\n// If we don't have models (no migrations), set to empty object\nschema.models = schema.models || {};\n\nmodule.exports = schema;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/my/bootstrapper.js":"'use strict';\n\nconst fs = require('fs');\nconst async = require('async');\nconst colors = require('colors/safe');\n\nconst Database = require('../required/db/database.js');\nconst SchemaGenerator = require('../required/db/schema_generator.js');\n\nconst ModelFactory = require('../required/model_factory.js');\n\nconst Config = require('./config.js');\n\nconst MIGRATION_PATH = './db/migrations';\n\nclass Bootstrapper {\n\n  constructor() {\n\n    this.cfg = Config.db.main;\n    this.rootCfg = Object.create(this.cfg);\n    this.rootCfg.database = 'postgres';\n\n  }\n\n  rootDb() {\n\n    let rootDb = new Database();\n    rootDb.connect(this.rootCfg);\n    return rootDb;\n\n  }\n\n  connect(callback) {\n\n    let db = new Database();\n\n    try {\n      db.connect(this.cfg);\n    } catch (e) {\n      return callback(e);\n    }\n\n    callback(null, db);\n\n  }\n\n  create(callback) {\n\n    this.rootDb().create(this.cfg.database, callback);\n\n  }\n\n  drop(callback) {\n\n    this.rootDb().drop(this.cfg.database, callback);\n\n  }\n\n  prepare(callback) {\n\n    this.connect((err, db) => {\n\n      if (err) {\n        return callback(err);\n      }\n\n      callback = this.wrapCallback(db, callback);\n\n      let schema = new SchemaGenerator(db);\n\n      db.transaction(\n        [\n          db.adapter.generateClearDatabaseQuery(),\n          db.adapter.generateCreateTableQuery('schema_migrations', [\n            {name: 'id', type: 'int', properties: {nullable: false, primary_key: true}},\n            {name: 'schema', type: 'string'}\n          ])\n        ].join(';'),\n        (err, result) => {\n\n          if (err) {\n            return callback(err);\n          }\n\n          schema.save();\n\n          callback(null, `Prepared database \"${db.adapter._config.database}\" for migrations`);\n\n        }\n      );\n\n    });\n\n  }\n\n  version(callback) {\n\n    this.connect((err, db) => {\n\n      if (err) {\n        return callback(err);\n      }\n\n      callback = this.wrapCallback(db, callback);\n\n      // Query schema by the Id column, descending\n      let orderClause = [{\n        columnNames: ['id'],\n        direction: 'DESC'\n      }];\n\n      // Only fetch one row\n      let limitClause = {\n        offset: 0,\n        count: 1\n      }\n\n      db.query(\n        db.adapter.generateSelectQuery(\n          null,\n          'schema_migrations',\n          ['id'],\n          null,\n          null,\n          null,\n          orderClause,\n          limitClause\n        ),\n        [],\n        (err, result) => {\n\n          if (err) {\n            return callback(new Error('Could not get schema migration version'));\n          }\n\n          if (result.rows && result.rows.length) {\n            return callback(null, `Schema version: ${result.rows[0].id}`);\n          } else {\n            return callback(new Error('No Migrations have been run'));\n          }\n\n        }\n      );\n\n    });\n\n  }\n\n  migrate(steps, callback) {\n\n    this.connect((err, db) => {\n\n      if (err) {\n        return callback(err);\n      }\n\n      callback = this.wrapCallback(db, callback);\n\n      steps = steps || 0;\n\n      db.query(db.adapter.generateSelectQuery(null, 'schema_migrations', ['id']), [], (err, result) => {\n\n        if (err) {\n          return callback(err);\n        }\n\n        if (!fs.existsSync(MIGRATION_PATH)) {\n          return callback(db.info(`No migrations in \"${MIGRATION_PATH}\"`))\n        } else {\n\n          let schema_ids = result.rows.map((v) => { return v.id; });\n\n          let migrations = fs.readdirSync(MIGRATION_PATH).map((v) => {\n            if(v.indexOf('.') === 0) return {};\n            return {\n              id: parseInt(v.substr(0, v.indexOf('__'))),\n              migration: new (require(process.cwd() + '/' + MIGRATION_PATH + '/' + v))(db)\n            };\n          }).filter((v) => {\n            return v.id && schema_ids.indexOf(v.id) === -1;\n          });\n\n          if (migrations.length === 0) {\n            return callback(db.info('No pending migrations'));\n          }\n\n          let migrateFuncs = migrations.map((v) => {\n\n            let migrationInstance = v.migration;\n\n            return (callback) => {\n              migrationInstance.executeUp(callback);\n            };\n\n          });\n\n          if (steps) {\n            migrateFuncs = migrateFuncs.slice(0, steps);\n          }\n\n          async.series(\n            migrateFuncs,\n            (err) => {\n\n              if (err) {\n                return callback(err);\n              }\n\n              callback(null, 'Migration completed successfully');\n\n            }\n          );\n        }\n\n      });\n\n    });\n\n  }\n\n  rollback(steps, callback) {\n\n    this.connect((err, db) => {\n\n      if (err) {\n        return callback(err);\n      }\n\n      callback = this.wrapCallback(db, callback);\n\n      steps = steps || 1;\n\n      db.query(db.adapter.generateSelectQuery(null, 'schema_migrations', ['id']), [], (err, result) => {\n\n        if (err) {\n          return callback(err);\n        }\n\n        if (!fs.existsSync(MIGRATION_PATH)) {\n          return callback(new Error(`No migrations in \"${MIGRATION_PATH}\"`))\n        }\n\n        let schema_ids = result.rows.map((v) => { return v.id; });\n\n        let migrations = fs.readdirSync(MIGRATION_PATH).map((v) => {\n          if(v.indexOf('.') === 0) return {};\n          return {\n            id: parseInt(v.substr(0, v.indexOf('__'))),\n            migration: new (require(process.cwd() + '/' + MIGRATION_PATH + '/' + v))(db)\n          };\n        }).filter((v) => {\n          return v.id && schema_ids.indexOf(v.id) !== -1;\n        }).reverse();\n\n        if (migrations.length === 0) {\n          return callback(new Error('Could not find any completed migrations'));\n        }\n\n        let migrateFuncs = migrations.map((v, i) => {\n\n          let migrationInstance = v.migration;\n          let nextMigrationInstanceId = migrations[i + 1] ? migrations[i + 1].migration.id : null;\n\n          return (callback) => {\n            migrationInstance.executeDown(callback, nextMigrationInstanceId);\n          };\n\n        }).slice(0, steps);\n\n        async.series(\n          migrateFuncs,\n          (err) => {\n\n            if (err) {\n              return callback(new Error('Migration rollback could not be completed'));\n            }\n\n            callback(null, 'Migration rollback complete!');\n\n          }\n        );\n\n      });\n\n    });\n\n  }\n\n  seed(callback) {\n\n    this.connect((err, db) => {\n\n      if (err) {\n        return callback(err);\n      }\n\n      callback = this.wrapCallback(db, callback);\n\n      let seed = Config.seed;\n\n      if (!seed) {\n        return callback(new Error('Could not seed, no seed found in \"./config/seed.json\". Please make sure JSON is correct.'));\n      }\n\n      return ModelFactory.populate(seed, callback);\n\n    });\n\n  }\n\n  wrapCallback(db, callback) {\n\n    return (err) => {\n      let cb = callback;\n      err && (cb = cb.bind(null, err));\n      db.close(cb);\n    }\n\n  }\n\n  bootstrap(callback) {\n\n    async.series([\n      (cb) => this.drop(cb),\n      (cb) => this.create(cb),\n      (cb) => this.prepare(cb),\n      (cb) => this.migrate(0, cb),\n      (cb) => this.seed(cb)\n    ], (err) => {\n\n      callback(err || null);\n\n    });\n\n  }\n\n  compose(callback) {\n\n    async.series([\n      (cb) => this.prepare(cb),\n      (cb) => this.migrate(0, cb),\n      (cb) => this.seed(cb)\n    ], (err) => {\n\n      callback(err || null);\n\n    });\n\n  }\n\n}\n\nmodule.exports = new Bootstrapper();\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/mocha/test.js":"'use strict';\n\nconst EndpointRequest = require('./endpoint_request.js');\n\nclass Test {\n\n  constructor(testRunner) {\n\n    this._data = {};\n    this.testRunner = testRunner;\n    Object.defineProperty(this, 'router', {get: () => this.testRunner.router});\n\n  }\n\n  __test__(verb) {\n\n    describe(this.constructor.name, () => {\n\n      this.before && before(done => this.before(done));\n      this.after && after(done => this.after(done));\n\n      this.test(verb);\n\n    });\n\n  }\n\n  set(key, value) {\n    return this._data[key] = value;\n  }\n\n  unset(key) {\n    delete this._data[key];\n  }\n\n  get(key, defaultValue) {\n    return this._data.hasOwnProperty(key) ? this._data[key] : defaultValue;\n  }\n\n  test() {}\n\n  /**\n  * Creates a new MockRequest object (emulates an HTTP request)\n  * @param {string} path The path you wish to hit\n  * @param {Object} query The query parameters you wish to pass\n  * @return {Nodal.EndpointRequest}\n  */\n  endpoint(path, query) {\n\n    return new EndpointRequest(this.router, path, query);\n\n  }\n\n}\n\nmodule.exports = Test;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/mocha/endpoint_request.js":"'use strict';\n\nconst qs = require('querystring');\n\nclass EndpointRequest {\n\n  constructor(router, path, params) {\n\n    this.router = router;\n    this.url = path + (params ? `?${qs.stringify(params)}` : '');\n    this.route = this.router.find(this.url);\n    this.token = null;\n\n    if (!this.route) {\n      throw new Error(`Route for ${this._path} does not exist`);\n    }\n\n  }\n\n  auth(token) {\n\n    if (this.token) {\n      throw new Error('Authorization token already set');\n    }\n\n    this.token = token;\n    return this;\n\n  }\n\n  mock(method, headers, body, callback) {\n\n    headers = headers || {};\n\n    if (this.token) {\n      headers['authorization'] = `Bearer ${this.token}`;\n    }\n\n    if (body instanceof Buffer) {\n      // do nothing\n    } else if (body && typeof body === 'object') {\n      body = new Buffer(JSON.stringify(body));\n      headers['content-type'] = 'application/json';\n    } else {\n      body = new Buffer(body + '');\n    }\n\n    return this.router.dispatch(\n      this.router.prepare(\n        '::1',\n        this.url,\n        method,\n        headers,\n        body\n      ),\n      (err, status, headers, body) => {\n\n        let json = null;\n\n        if (err) {\n          status = 500;\n          body = new Buffer(0);\n        } else {\n\n          try {\n            json = JSON.parse(body.toString());\n          } catch (e) {\n            json = null;\n          }\n\n        }\n\n        callback(status, headers, body, json);\n\n      }\n    );\n\n  }\n\n  get(callback) {\n\n    this.mock('GET', {}, null, callback);\n\n  }\n\n  del(callback) {\n\n    this.mock('DELETE', {}, null, callback);\n\n  }\n\n  post(body, callback) {\n\n    this.mock('POST', {}, body, callback);\n\n  }\n\n  put(body, callback) {\n\n    this.mock('PUT', {}, body, callback);\n\n  }\n\n}\n\nmodule.exports = EndpointRequest;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/core/mocha/test_runner.js":"'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\n\nclass TestRunner {\n\n  constructor(dir, router) {\n\n    this.dir = dir;\n    this.router = router;\n\n  }\n\n  tests() {\n\n    let tests = [];\n    let filter;\n\n    if (process.argv.length > 3) {\n      filter = process.argv[3];\n      filter = filter.endsWith('.js') ? filter : `${filter}.js`;\n    }\n\n    let addTest = dir => {\n\n      return filename => {\n\n        if (!path.extname(filename) && filename[0] !== '.') {\n\n          let nextDir = path.resolve(dir, filename);\n          return fs.readdirSync(nextDir).forEach(addCommand(nextDir));\n\n        }\n\n        if (filter && filename !== filter) {\n          return;\n        }\n\n        let Test = require(path.resolve(dir, filename));\n        tests.push(new Test(this));\n\n      }\n\n    };\n\n    let testDir = path.resolve(process.cwd(), this.dir || '/');\n    fs.readdirSync(testDir).forEach(addTest(testDir));\n\n    return tests;\n\n  }\n\n  start(verb) {\n\n    this.tests().forEach(t => {\n\n      t.__test__(verb);\n\n    });\n\n  }\n\n}\n\nmodule.exports = TestRunner;\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/cli/bin.js":"#!/usr/bin/env node\n\n'use strict';\n\nconst CLI = require('./cli.js');\nCLI.run(process.argv.slice(2));\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/src/cluster.js":"'use strict';\n\nconst Nodal = require('nodal');\nconst cluster = require('cluster');\n\nif (cluster.isMaster) {\n\n  const daemon = new Nodal.Daemon();\n  daemon.start(Nodal.my.Config.secrets.port);\n\n} else {\n\n  const app = new Nodal.Application();\n  app.listen(Nodal.my.Config.secrets.port);\n\n}\n","/home/travis/build/npmtest/node-npmtest-nodal/node_modules/nodal/src/worker.js":"'use strict';\n\nconst Nodal = require('nodal');\n\nconst SchedulerMain = Nodal.require('schedulers/main.js');\n\nSchedulerMain.start();\n"}